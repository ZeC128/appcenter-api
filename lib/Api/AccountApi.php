<?php
/**
 * AccountApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * App Center Client
 *
 * Microsoft Visual Studio App Center API
 *
 * OpenAPI spec version: v0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * AccountApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AccountApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation appApiTokensDelete
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appApiTokensDelete($owner_name, $app_name, $api_token_id)
    {
        $this->appApiTokensDeleteWithHttpInfo($owner_name, $app_name, $api_token_id);
    }

    /**
     * Operation appApiTokensDeleteWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appApiTokensDeleteWithHttpInfo($owner_name, $app_name, $api_token_id)
    {
        $returnType = '';
        $request = $this->appApiTokensDeleteRequest($owner_name, $app_name, $api_token_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appApiTokensDeleteAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appApiTokensDeleteAsync($owner_name, $app_name, $api_token_id)
    {
        return $this->appApiTokensDeleteAsyncWithHttpInfo($owner_name, $app_name, $api_token_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appApiTokensDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appApiTokensDeleteAsyncWithHttpInfo($owner_name, $app_name, $api_token_id)
    {
        $returnType = '';
        $request = $this->appApiTokensDeleteRequest($owner_name, $app_name, $api_token_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appApiTokensDelete'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appApiTokensDeleteRequest($owner_name, $app_name, $api_token_id)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appApiTokensDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appApiTokensDelete'
            );
        }
        // verify the required parameter 'api_token_id' is set
        if ($api_token_id === null || (is_array($api_token_id) && count($api_token_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token_id when calling appApiTokensDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/api_tokens/{api_token_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($api_token_id !== null) {
            $resourcePath = str_replace(
                '{' . 'api_token_id' . '}',
                ObjectSerializer::toPathValue($api_token_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appApiTokensList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20078[]
     */
    public function appApiTokensList($owner_name, $app_name)
    {
        list($response) = $this->appApiTokensListWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appApiTokensListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20078[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appApiTokensListWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20078[]';
        $request = $this->appApiTokensListRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20078[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appApiTokensListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appApiTokensListAsync($owner_name, $app_name)
    {
        return $this->appApiTokensListAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appApiTokensListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appApiTokensListAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20078[]';
        $request = $this->appApiTokensListRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appApiTokensList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appApiTokensListRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appApiTokensList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appApiTokensList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/api_tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appApiTokensNew
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Description $description Description of the token (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appApiTokensNew($owner_name, $app_name, $description = null)
    {
        list($response) = $this->appApiTokensNewWithHttpInfo($owner_name, $app_name, $description);
        return $response;
    }

    /**
     * Operation appApiTokensNewWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Description $description Description of the token (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appApiTokensNewWithHttpInfo($owner_name, $app_name, $description = null)
    {
        $returnType = 'object';
        $request = $this->appApiTokensNewRequest($owner_name, $app_name, $description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appApiTokensNewAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Description $description Description of the token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appApiTokensNewAsync($owner_name, $app_name, $description = null)
    {
        return $this->appApiTokensNewAsyncWithHttpInfo($owner_name, $app_name, $description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appApiTokensNewAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Description $description Description of the token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appApiTokensNewAsyncWithHttpInfo($owner_name, $app_name, $description = null)
    {
        $returnType = 'object';
        $request = $this->appApiTokensNewRequest($owner_name, $app_name, $description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appApiTokensNew'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Description $description Description of the token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appApiTokensNewRequest($owner_name, $app_name, $description = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appApiTokensNew'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appApiTokensNew'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/api_tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($description)) {
            $_tempBody = $description;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsAccept
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appInvitationsAccept($invitation_token)
    {
        $this->appInvitationsAcceptWithHttpInfo($invitation_token);
    }

    /**
     * Operation appInvitationsAcceptWithHttpInfo
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsAcceptWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->appInvitationsAcceptRequest($invitation_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsAcceptAsync
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsAcceptAsync($invitation_token)
    {
        return $this->appInvitationsAcceptAsyncWithHttpInfo($invitation_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsAcceptAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsAcceptAsyncWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->appInvitationsAcceptRequest($invitation_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsAccept'
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsAcceptRequest($invitation_token)
    {
        // verify the required parameter 'invitation_token' is set
        if ($invitation_token === null || (is_array($invitation_token) && count($invitation_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invitation_token when calling appInvitationsAccept'
            );
        }

        $resourcePath = '/v0.1/user/invitations/apps/{invitation_token}/accept';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invitation_token !== null) {
            $resourcePath = str_replace(
                '{' . 'invitation_token' . '}',
                ObjectSerializer::toPathValue($invitation_token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsCreate
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\UserEmail3 $user_email The email of the user to invite (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appInvitationsCreate($owner_name, $app_name, $user_email = null)
    {
        $this->appInvitationsCreateWithHttpInfo($owner_name, $app_name, $user_email);
    }

    /**
     * Operation appInvitationsCreateWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\UserEmail3 $user_email The email of the user to invite (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsCreateWithHttpInfo($owner_name, $app_name, $user_email = null)
    {
        $returnType = '';
        $request = $this->appInvitationsCreateRequest($owner_name, $app_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsCreateAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\UserEmail3 $user_email The email of the user to invite (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsCreateAsync($owner_name, $app_name, $user_email = null)
    {
        return $this->appInvitationsCreateAsyncWithHttpInfo($owner_name, $app_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\UserEmail3 $user_email The email of the user to invite (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsCreateAsyncWithHttpInfo($owner_name, $app_name, $user_email = null)
    {
        $returnType = '';
        $request = $this->appInvitationsCreateRequest($owner_name, $app_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsCreate'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\UserEmail3 $user_email The email of the user to invite (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsCreateRequest($owner_name, $app_name, $user_email = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appInvitationsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appInvitationsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_email)) {
            $_tempBody = $user_email;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsCreateByEmail
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appInvitationsCreateByEmail($owner_name, $app_name, $user_email)
    {
        $this->appInvitationsCreateByEmailWithHttpInfo($owner_name, $app_name, $user_email);
    }

    /**
     * Operation appInvitationsCreateByEmailWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsCreateByEmailWithHttpInfo($owner_name, $app_name, $user_email)
    {
        $returnType = '';
        $request = $this->appInvitationsCreateByEmailRequest($owner_name, $app_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsCreateByEmailAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsCreateByEmailAsync($owner_name, $app_name, $user_email)
    {
        return $this->appInvitationsCreateByEmailAsyncWithHttpInfo($owner_name, $app_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsCreateByEmailAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsCreateByEmailAsyncWithHttpInfo($owner_name, $app_name, $user_email)
    {
        $returnType = '';
        $request = $this->appInvitationsCreateByEmailRequest($owner_name, $app_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsCreateByEmail'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsCreateByEmailRequest($owner_name, $app_name, $user_email)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appInvitationsCreateByEmail'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appInvitationsCreateByEmail'
            );
        }
        // verify the required parameter 'user_email' is set
        if ($user_email === null || (is_array($user_email) && count($user_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_email when calling appInvitationsCreateByEmail'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($user_email !== null) {
            $resourcePath = str_replace(
                '{' . 'user_email' . '}',
                ObjectSerializer::toPathValue($user_email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsDelete
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appInvitationsDelete($owner_name, $app_name, $user_email)
    {
        $this->appInvitationsDeleteWithHttpInfo($owner_name, $app_name, $user_email);
    }

    /**
     * Operation appInvitationsDeleteWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsDeleteWithHttpInfo($owner_name, $app_name, $user_email)
    {
        $returnType = '';
        $request = $this->appInvitationsDeleteRequest($owner_name, $app_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsDeleteAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsDeleteAsync($owner_name, $app_name, $user_email)
    {
        return $this->appInvitationsDeleteAsyncWithHttpInfo($owner_name, $app_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsDeleteAsyncWithHttpInfo($owner_name, $app_name, $user_email)
    {
        $returnType = '';
        $request = $this->appInvitationsDeleteRequest($owner_name, $app_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsDelete'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsDeleteRequest($owner_name, $app_name, $user_email)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appInvitationsDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appInvitationsDelete'
            );
        }
        // verify the required parameter 'user_email' is set
        if ($user_email === null || (is_array($user_email) && count($user_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_email when calling appInvitationsDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($user_email !== null) {
            $resourcePath = str_replace(
                '{' . 'user_email' . '}',
                ObjectSerializer::toPathValue($user_email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appInvitationsList($owner_name, $app_name)
    {
        list($response) = $this->appInvitationsListWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appInvitationsListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsListWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appInvitationsListRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsListAsync($owner_name, $app_name)
    {
        return $this->appInvitationsListAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsListAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appInvitationsListRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsListRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appInvitationsList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appInvitationsList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsReject
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appInvitationsReject($invitation_token)
    {
        $this->appInvitationsRejectWithHttpInfo($invitation_token);
    }

    /**
     * Operation appInvitationsRejectWithHttpInfo
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsRejectWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->appInvitationsRejectRequest($invitation_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsRejectAsync
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsRejectAsync($invitation_token)
    {
        return $this->appInvitationsRejectAsyncWithHttpInfo($invitation_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsRejectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsRejectAsyncWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->appInvitationsRejectRequest($invitation_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsReject'
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsRejectRequest($invitation_token)
    {
        // verify the required parameter 'invitation_token' is set
        if ($invitation_token === null || (is_array($invitation_token) && count($invitation_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invitation_token when calling appInvitationsReject'
            );
        }

        $resourcePath = '/v0.1/user/invitations/apps/{invitation_token}/reject';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invitation_token !== null) {
            $resourcePath = str_replace(
                '{' . 'invitation_token' . '}',
                ObjectSerializer::toPathValue($invitation_token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appInvitationsUpdatePermissions
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     * @param  \Swagger\Client\Model\UserInvitationPermissionsData $user_invitation_permissions_data The value to update the user permission in the invite. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appInvitationsUpdatePermissions($owner_name, $app_name, $user_email, $user_invitation_permissions_data = null)
    {
        $this->appInvitationsUpdatePermissionsWithHttpInfo($owner_name, $app_name, $user_email, $user_invitation_permissions_data);
    }

    /**
     * Operation appInvitationsUpdatePermissionsWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     * @param  \Swagger\Client\Model\UserInvitationPermissionsData $user_invitation_permissions_data The value to update the user permission in the invite. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appInvitationsUpdatePermissionsWithHttpInfo($owner_name, $app_name, $user_email, $user_invitation_permissions_data = null)
    {
        $returnType = '';
        $request = $this->appInvitationsUpdatePermissionsRequest($owner_name, $app_name, $user_email, $user_invitation_permissions_data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appInvitationsUpdatePermissionsAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     * @param  \Swagger\Client\Model\UserInvitationPermissionsData $user_invitation_permissions_data The value to update the user permission in the invite. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsUpdatePermissionsAsync($owner_name, $app_name, $user_email, $user_invitation_permissions_data = null)
    {
        return $this->appInvitationsUpdatePermissionsAsyncWithHttpInfo($owner_name, $app_name, $user_email, $user_invitation_permissions_data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appInvitationsUpdatePermissionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     * @param  \Swagger\Client\Model\UserInvitationPermissionsData $user_invitation_permissions_data The value to update the user permission in the invite. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appInvitationsUpdatePermissionsAsyncWithHttpInfo($owner_name, $app_name, $user_email, $user_invitation_permissions_data = null)
    {
        $returnType = '';
        $request = $this->appInvitationsUpdatePermissionsRequest($owner_name, $app_name, $user_email, $user_invitation_permissions_data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appInvitationsUpdatePermissions'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The email of the user to invite (required)
     * @param  \Swagger\Client\Model\UserInvitationPermissionsData $user_invitation_permissions_data The value to update the user permission in the invite. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appInvitationsUpdatePermissionsRequest($owner_name, $app_name, $user_email, $user_invitation_permissions_data = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appInvitationsUpdatePermissions'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appInvitationsUpdatePermissions'
            );
        }
        // verify the required parameter 'user_email' is set
        if ($user_email === null || (is_array($user_email) && count($user_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_email when calling appInvitationsUpdatePermissions'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($user_email !== null) {
            $resourcePath = str_replace(
                '{' . 'user_email' . '}',
                ObjectSerializer::toPathValue($user_email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_invitation_permissions_data)) {
            $_tempBody = $user_invitation_permissions_data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsCreate
     *
     * @param  \Swagger\Client\Model\App3 $app The data for the app (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsCreate($app)
    {
        list($response) = $this->appsCreateWithHttpInfo($app);
        return $response;
    }

    /**
     * Operation appsCreateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\App3 $app The data for the app (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsCreateWithHttpInfo($app)
    {
        $returnType = 'object';
        $request = $this->appsCreateRequest($app);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsCreateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\App3 $app The data for the app (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsCreateAsync($app)
    {
        return $this->appsCreateAsyncWithHttpInfo($app)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\App3 $app The data for the app (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsCreateAsyncWithHttpInfo($app)
    {
        $returnType = 'object';
        $request = $this->appsCreateRequest($app);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsCreate'
     *
     * @param  \Swagger\Client\Model\App3 $app The data for the app (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsCreateRequest($app)
    {
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling appsCreate'
            );
        }

        $resourcePath = '/v0.1/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($app)) {
            $_tempBody = $app;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsCreateForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\App1 $app The data for the app (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsCreateForOrg($org_name, $app)
    {
        list($response) = $this->appsCreateForOrgWithHttpInfo($org_name, $app);
        return $response;
    }

    /**
     * Operation appsCreateForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\App1 $app The data for the app (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsCreateForOrgWithHttpInfo($org_name, $app)
    {
        $returnType = 'object';
        $request = $this->appsCreateForOrgRequest($org_name, $app);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsCreateForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\App1 $app The data for the app (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsCreateForOrgAsync($org_name, $app)
    {
        return $this->appsCreateForOrgAsyncWithHttpInfo($org_name, $app)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsCreateForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\App1 $app The data for the app (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsCreateForOrgAsyncWithHttpInfo($org_name, $app)
    {
        $returnType = 'object';
        $request = $this->appsCreateForOrgRequest($org_name, $app);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsCreateForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\App1 $app The data for the app (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsCreateForOrgRequest($org_name, $app)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling appsCreateForOrg'
            );
        }
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling appsCreateForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($app)) {
            $_tempBody = $app;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsDelete
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appsDelete($app_name, $owner_name)
    {
        $this->appsDeleteWithHttpInfo($app_name, $owner_name);
    }

    /**
     * Operation appsDeleteWithHttpInfo
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsDeleteWithHttpInfo($app_name, $owner_name)
    {
        $returnType = '';
        $request = $this->appsDeleteRequest($app_name, $owner_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsDeleteAsync
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsDeleteAsync($app_name, $owner_name)
    {
        return $this->appsDeleteAsyncWithHttpInfo($app_name, $owner_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsDeleteAsyncWithHttpInfo($app_name, $owner_name)
    {
        $returnType = '';
        $request = $this->appsDeleteRequest($app_name, $owner_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsDelete'
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsDeleteRequest($app_name, $owner_name)
    {
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsDeleteAvatar
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsDeleteAvatar($owner_name, $app_name)
    {
        list($response) = $this->appsDeleteAvatarWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appsDeleteAvatarWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsDeleteAvatarWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appsDeleteAvatarRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsDeleteAvatarAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsDeleteAvatarAsync($owner_name, $app_name)
    {
        return $this->appsDeleteAvatarAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsDeleteAvatarAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsDeleteAvatarAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appsDeleteAvatarRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsDeleteAvatar'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsDeleteAvatarRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsDeleteAvatar'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsDeleteAvatar'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsGet
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsGet($owner_name, $app_name)
    {
        list($response) = $this->appsGetWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appsGetWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsGetWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appsGetRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsGetAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsGetAsync($owner_name, $app_name)
    {
        return $this->appsGetAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsGetAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appsGetRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsGet'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsGetRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsGetForOrgUser
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function appsGetForOrgUser($org_name, $user_name)
    {
        list($response) = $this->appsGetForOrgUserWithHttpInfo($org_name, $user_name);
        return $response;
    }

    /**
     * Operation appsGetForOrgUserWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appsGetForOrgUserWithHttpInfo($org_name, $user_name)
    {
        $returnType = 'object[]';
        $request = $this->appsGetForOrgUserRequest($org_name, $user_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsGetForOrgUserAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsGetForOrgUserAsync($org_name, $user_name)
    {
        return $this->appsGetForOrgUserAsyncWithHttpInfo($org_name, $user_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsGetForOrgUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsGetForOrgUserAsyncWithHttpInfo($org_name, $user_name)
    {
        $returnType = 'object[]';
        $request = $this->appsGetForOrgUserRequest($org_name, $user_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsGetForOrgUser'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsGetForOrgUserRequest($org_name, $user_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling appsGetForOrgUser'
            );
        }
        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling appsGetForOrgUser'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/users/{user_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsGetTeams
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function appsGetTeams($app_name, $owner_name)
    {
        list($response) = $this->appsGetTeamsWithHttpInfo($app_name, $owner_name);
        return $response;
    }

    /**
     * Operation appsGetTeamsWithHttpInfo
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appsGetTeamsWithHttpInfo($app_name, $owner_name)
    {
        $returnType = 'object[]';
        $request = $this->appsGetTeamsRequest($app_name, $owner_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsGetTeamsAsync
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsGetTeamsAsync($app_name, $owner_name)
    {
        return $this->appsGetTeamsAsyncWithHttpInfo($app_name, $owner_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsGetTeamsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsGetTeamsAsyncWithHttpInfo($app_name, $owner_name)
    {
        $returnType = 'object[]';
        $request = $this->appsGetTeamsRequest($app_name, $owner_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsGetTeams'
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsGetTeamsRequest($app_name, $owner_name)
    {
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsGetTeams'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsGetTeams'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsList
     *
     * @param  string $order_by The name of the attribute by which to order the response by. By default, apps are in order of creation. All results are ordered in ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function appsList($order_by = null)
    {
        list($response) = $this->appsListWithHttpInfo($order_by);
        return $response;
    }

    /**
     * Operation appsListWithHttpInfo
     *
     * @param  string $order_by The name of the attribute by which to order the response by. By default, apps are in order of creation. All results are ordered in ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appsListWithHttpInfo($order_by = null)
    {
        $returnType = 'object[]';
        $request = $this->appsListRequest($order_by);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsListAsync
     *
     * 
     *
     * @param  string $order_by The name of the attribute by which to order the response by. By default, apps are in order of creation. All results are ordered in ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsListAsync($order_by = null)
    {
        return $this->appsListAsyncWithHttpInfo($order_by)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $order_by The name of the attribute by which to order the response by. By default, apps are in order of creation. All results are ordered in ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsListAsyncWithHttpInfo($order_by = null)
    {
        $returnType = 'object[]';
        $request = $this->appsListRequest($order_by);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsList'
     *
     * @param  string $order_by The name of the attribute by which to order the response by. By default, apps are in order of creation. All results are ordered in ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsListRequest($order_by = null)
    {

        $resourcePath = '/v0.1/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($order_by !== null) {
            $queryParams['$orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsListForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function appsListForOrg($org_name)
    {
        list($response) = $this->appsListForOrgWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation appsListForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appsListForOrgWithHttpInfo($org_name)
    {
        $returnType = 'object[]';
        $request = $this->appsListForOrgRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsListForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsListForOrgAsync($org_name)
    {
        return $this->appsListForOrgAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsListForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsListForOrgAsyncWithHttpInfo($org_name)
    {
        $returnType = 'object[]';
        $request = $this->appsListForOrgRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsListForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsListForOrgRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling appsListForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsListTesters
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20020[]
     */
    public function appsListTesters($owner_name, $app_name)
    {
        list($response) = $this->appsListTestersWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appsListTestersWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20020[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appsListTestersWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20020[]';
        $request = $this->appsListTestersRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20020[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsListTestersAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsListTestersAsync($owner_name, $app_name)
    {
        return $this->appsListTestersAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsListTestersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsListTestersAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20020[]';
        $request = $this->appsListTestersRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsListTesters'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsListTestersRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsListTesters'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsListTesters'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/testers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsRemoveUser
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appsRemoveUser($owner_name, $app_name, $user_email)
    {
        $this->appsRemoveUserWithHttpInfo($owner_name, $app_name, $user_email);
    }

    /**
     * Operation appsRemoveUserWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsRemoveUserWithHttpInfo($owner_name, $app_name, $user_email)
    {
        $returnType = '';
        $request = $this->appsRemoveUserRequest($owner_name, $app_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsRemoveUserAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsRemoveUserAsync($owner_name, $app_name, $user_email)
    {
        return $this->appsRemoveUserAsyncWithHttpInfo($owner_name, $app_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsRemoveUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsRemoveUserAsyncWithHttpInfo($owner_name, $app_name, $user_email)
    {
        $returnType = '';
        $request = $this->appsRemoveUserRequest($owner_name, $app_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsRemoveUser'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsRemoveUserRequest($owner_name, $app_name, $user_email)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsRemoveUser'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsRemoveUser'
            );
        }
        // verify the required parameter 'user_email' is set
        if ($user_email === null || (is_array($user_email) && count($user_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_email when calling appsRemoveUser'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/users/{user_email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($user_email !== null) {
            $resourcePath = str_replace(
                '{' . 'user_email' . '}',
                ObjectSerializer::toPathValue($user_email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsTransferOwnership
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $destination_owner_name The name of the owner (user or organization) to which the app is being transferred (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsTransferOwnership($owner_name, $app_name, $destination_owner_name)
    {
        list($response) = $this->appsTransferOwnershipWithHttpInfo($owner_name, $app_name, $destination_owner_name);
        return $response;
    }

    /**
     * Operation appsTransferOwnershipWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $destination_owner_name The name of the owner (user or organization) to which the app is being transferred (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsTransferOwnershipWithHttpInfo($owner_name, $app_name, $destination_owner_name)
    {
        $returnType = 'object';
        $request = $this->appsTransferOwnershipRequest($owner_name, $app_name, $destination_owner_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsTransferOwnershipAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $destination_owner_name The name of the owner (user or organization) to which the app is being transferred (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsTransferOwnershipAsync($owner_name, $app_name, $destination_owner_name)
    {
        return $this->appsTransferOwnershipAsyncWithHttpInfo($owner_name, $app_name, $destination_owner_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsTransferOwnershipAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $destination_owner_name The name of the owner (user or organization) to which the app is being transferred (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsTransferOwnershipAsyncWithHttpInfo($owner_name, $app_name, $destination_owner_name)
    {
        $returnType = 'object';
        $request = $this->appsTransferOwnershipRequest($owner_name, $app_name, $destination_owner_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsTransferOwnership'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $destination_owner_name The name of the owner (user or organization) to which the app is being transferred (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsTransferOwnershipRequest($owner_name, $app_name, $destination_owner_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsTransferOwnership'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsTransferOwnership'
            );
        }
        // verify the required parameter 'destination_owner_name' is set
        if ($destination_owner_name === null || (is_array($destination_owner_name) && count($destination_owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination_owner_name when calling appsTransferOwnership'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/transfer/{destination_owner_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($destination_owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'destination_owner_name' . '}',
                ObjectSerializer::toPathValue($destination_owner_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json', 'application/octet-stream']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsTransferToOrg
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsTransferToOrg($owner_name, $app_name)
    {
        list($response) = $this->appsTransferToOrgWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appsTransferToOrgWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsTransferToOrgWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appsTransferToOrgRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsTransferToOrgAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsTransferToOrgAsync($owner_name, $app_name)
    {
        return $this->appsTransferToOrgAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsTransferToOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsTransferToOrgAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appsTransferToOrgRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsTransferToOrg'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsTransferToOrgRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsTransferToOrg'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsTransferToOrg'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/transfer_to_org';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsUpdate
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  \Swagger\Client\Model\App2 $app The partial data for the app (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsUpdate($app_name, $owner_name, $app = null)
    {
        list($response) = $this->appsUpdateWithHttpInfo($app_name, $owner_name, $app);
        return $response;
    }

    /**
     * Operation appsUpdateWithHttpInfo
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  \Swagger\Client\Model\App2 $app The partial data for the app (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsUpdateWithHttpInfo($app_name, $owner_name, $app = null)
    {
        $returnType = 'object';
        $request = $this->appsUpdateRequest($app_name, $owner_name, $app);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsUpdateAsync
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  \Swagger\Client\Model\App2 $app The partial data for the app (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsUpdateAsync($app_name, $owner_name, $app = null)
    {
        return $this->appsUpdateAsyncWithHttpInfo($app_name, $owner_name, $app)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  \Swagger\Client\Model\App2 $app The partial data for the app (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsUpdateAsyncWithHttpInfo($app_name, $owner_name, $app = null)
    {
        $returnType = 'object';
        $request = $this->appsUpdateRequest($app_name, $owner_name, $app);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsUpdate'
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  \Swagger\Client\Model\App2 $app The partial data for the app (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsUpdateRequest($app_name, $owner_name, $app = null)
    {
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($app)) {
            $_tempBody = $app;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsUpdateAvatar
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \SplFileObject $avatar The image for an app avatar to upload. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appsUpdateAvatar($owner_name, $app_name, $avatar = null)
    {
        list($response) = $this->appsUpdateAvatarWithHttpInfo($owner_name, $app_name, $avatar);
        return $response;
    }

    /**
     * Operation appsUpdateAvatarWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \SplFileObject $avatar The image for an app avatar to upload. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsUpdateAvatarWithHttpInfo($owner_name, $app_name, $avatar = null)
    {
        $returnType = 'object';
        $request = $this->appsUpdateAvatarRequest($owner_name, $app_name, $avatar);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsUpdateAvatarAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \SplFileObject $avatar The image for an app avatar to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsUpdateAvatarAsync($owner_name, $app_name, $avatar = null)
    {
        return $this->appsUpdateAvatarAsyncWithHttpInfo($owner_name, $app_name, $avatar)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsUpdateAvatarAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \SplFileObject $avatar The image for an app avatar to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsUpdateAvatarAsyncWithHttpInfo($owner_name, $app_name, $avatar = null)
    {
        $returnType = 'object';
        $request = $this->appsUpdateAvatarRequest($owner_name, $app_name, $avatar);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsUpdateAvatar'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \SplFileObject $avatar The image for an app avatar to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsUpdateAvatarRequest($owner_name, $app_name, $avatar = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsUpdateAvatar'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsUpdateAvatar'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // form params
        if ($avatar !== null) {
            $multipart = true;
            $formParams['avatar'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($avatar), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsUpdateUserPermissions
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to patch (required)
     * @param  \Swagger\Client\Model\UserAppPermissionsData $user_app_permissions_data The value to update the user permission for the app. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appsUpdateUserPermissions($owner_name, $app_name, $user_email, $user_app_permissions_data = null)
    {
        $this->appsUpdateUserPermissionsWithHttpInfo($owner_name, $app_name, $user_email, $user_app_permissions_data);
    }

    /**
     * Operation appsUpdateUserPermissionsWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to patch (required)
     * @param  \Swagger\Client\Model\UserAppPermissionsData $user_app_permissions_data The value to update the user permission for the app. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsUpdateUserPermissionsWithHttpInfo($owner_name, $app_name, $user_email, $user_app_permissions_data = null)
    {
        $returnType = '';
        $request = $this->appsUpdateUserPermissionsRequest($owner_name, $app_name, $user_email, $user_app_permissions_data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appsUpdateUserPermissionsAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to patch (required)
     * @param  \Swagger\Client\Model\UserAppPermissionsData $user_app_permissions_data The value to update the user permission for the app. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsUpdateUserPermissionsAsync($owner_name, $app_name, $user_email, $user_app_permissions_data = null)
    {
        return $this->appsUpdateUserPermissionsAsyncWithHttpInfo($owner_name, $app_name, $user_email, $user_app_permissions_data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsUpdateUserPermissionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to patch (required)
     * @param  \Swagger\Client\Model\UserAppPermissionsData $user_app_permissions_data The value to update the user permission for the app. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsUpdateUserPermissionsAsyncWithHttpInfo($owner_name, $app_name, $user_email, $user_app_permissions_data = null)
    {
        $returnType = '';
        $request = $this->appsUpdateUserPermissionsRequest($owner_name, $app_name, $user_email, $user_app_permissions_data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsUpdateUserPermissions'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $user_email The user email of the user to patch (required)
     * @param  \Swagger\Client\Model\UserAppPermissionsData $user_app_permissions_data The value to update the user permission for the app. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsUpdateUserPermissionsRequest($owner_name, $app_name, $user_email, $user_app_permissions_data = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appsUpdateUserPermissions'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appsUpdateUserPermissions'
            );
        }
        // verify the required parameter 'user_email' is set
        if ($user_email === null || (is_array($user_email) && count($user_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_email when calling appsUpdateUserPermissions'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/users/{user_email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($user_email !== null) {
            $resourcePath = str_replace(
                '{' . 'user_email' . '}',
                ObjectSerializer::toPathValue($user_email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_app_permissions_data)) {
            $_tempBody = $user_app_permissions_data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation azureSubscriptionDeleteForApp
     *
     * @param  string $azure_subscription_id The unique ID (UUID) of the azure subscription (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function azureSubscriptionDeleteForApp($azure_subscription_id, $owner_name, $app_name)
    {
        $this->azureSubscriptionDeleteForAppWithHttpInfo($azure_subscription_id, $owner_name, $app_name);
    }

    /**
     * Operation azureSubscriptionDeleteForAppWithHttpInfo
     *
     * @param  string $azure_subscription_id The unique ID (UUID) of the azure subscription (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function azureSubscriptionDeleteForAppWithHttpInfo($azure_subscription_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->azureSubscriptionDeleteForAppRequest($azure_subscription_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation azureSubscriptionDeleteForAppAsync
     *
     * 
     *
     * @param  string $azure_subscription_id The unique ID (UUID) of the azure subscription (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionDeleteForAppAsync($azure_subscription_id, $owner_name, $app_name)
    {
        return $this->azureSubscriptionDeleteForAppAsyncWithHttpInfo($azure_subscription_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation azureSubscriptionDeleteForAppAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $azure_subscription_id The unique ID (UUID) of the azure subscription (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionDeleteForAppAsyncWithHttpInfo($azure_subscription_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->azureSubscriptionDeleteForAppRequest($azure_subscription_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'azureSubscriptionDeleteForApp'
     *
     * @param  string $azure_subscription_id The unique ID (UUID) of the azure subscription (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function azureSubscriptionDeleteForAppRequest($azure_subscription_id, $owner_name, $app_name)
    {
        // verify the required parameter 'azure_subscription_id' is set
        if ($azure_subscription_id === null || (is_array($azure_subscription_id) && count($azure_subscription_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $azure_subscription_id when calling azureSubscriptionDeleteForApp'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling azureSubscriptionDeleteForApp'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling azureSubscriptionDeleteForApp'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions/{azure_subscription_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($azure_subscription_id !== null) {
            $resourcePath = str_replace(
                '{' . 'azure_subscription_id' . '}',
                ObjectSerializer::toPathValue($azure_subscription_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation azureSubscriptionLinkForApp
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\AzureSubscriptionToAppData $azure_subscription_to_app_data The azure subscription data needed to be link to the app. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function azureSubscriptionLinkForApp($owner_name, $app_name, $azure_subscription_to_app_data)
    {
        $this->azureSubscriptionLinkForAppWithHttpInfo($owner_name, $app_name, $azure_subscription_to_app_data);
    }

    /**
     * Operation azureSubscriptionLinkForAppWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\AzureSubscriptionToAppData $azure_subscription_to_app_data The azure subscription data needed to be link to the app. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function azureSubscriptionLinkForAppWithHttpInfo($owner_name, $app_name, $azure_subscription_to_app_data)
    {
        $returnType = '';
        $request = $this->azureSubscriptionLinkForAppRequest($owner_name, $app_name, $azure_subscription_to_app_data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation azureSubscriptionLinkForAppAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\AzureSubscriptionToAppData $azure_subscription_to_app_data The azure subscription data needed to be link to the app. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionLinkForAppAsync($owner_name, $app_name, $azure_subscription_to_app_data)
    {
        return $this->azureSubscriptionLinkForAppAsyncWithHttpInfo($owner_name, $app_name, $azure_subscription_to_app_data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation azureSubscriptionLinkForAppAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\AzureSubscriptionToAppData $azure_subscription_to_app_data The azure subscription data needed to be link to the app. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionLinkForAppAsyncWithHttpInfo($owner_name, $app_name, $azure_subscription_to_app_data)
    {
        $returnType = '';
        $request = $this->azureSubscriptionLinkForAppRequest($owner_name, $app_name, $azure_subscription_to_app_data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'azureSubscriptionLinkForApp'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\AzureSubscriptionToAppData $azure_subscription_to_app_data The azure subscription data needed to be link to the app. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function azureSubscriptionLinkForAppRequest($owner_name, $app_name, $azure_subscription_to_app_data)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling azureSubscriptionLinkForApp'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling azureSubscriptionLinkForApp'
            );
        }
        // verify the required parameter 'azure_subscription_to_app_data' is set
        if ($azure_subscription_to_app_data === null || (is_array($azure_subscription_to_app_data) && count($azure_subscription_to_app_data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $azure_subscription_to_app_data when calling azureSubscriptionLinkForApp'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($azure_subscription_to_app_data)) {
            $_tempBody = $azure_subscription_to_app_data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation azureSubscriptionListForApp
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20012[]
     */
    public function azureSubscriptionListForApp($owner_name, $app_name)
    {
        list($response) = $this->azureSubscriptionListForAppWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation azureSubscriptionListForAppWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20012[], HTTP status code, HTTP response headers (array of strings)
     */
    public function azureSubscriptionListForAppWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012[]';
        $request = $this->azureSubscriptionListForAppRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20012[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation azureSubscriptionListForAppAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionListForAppAsync($owner_name, $app_name)
    {
        return $this->azureSubscriptionListForAppAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation azureSubscriptionListForAppAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionListForAppAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012[]';
        $request = $this->azureSubscriptionListForAppRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'azureSubscriptionListForApp'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function azureSubscriptionListForAppRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling azureSubscriptionListForApp'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling azureSubscriptionListForApp'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation azureSubscriptionListForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20012[]
     */
    public function azureSubscriptionListForOrg($org_name)
    {
        list($response) = $this->azureSubscriptionListForOrgWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation azureSubscriptionListForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20012[], HTTP status code, HTTP response headers (array of strings)
     */
    public function azureSubscriptionListForOrgWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012[]';
        $request = $this->azureSubscriptionListForOrgRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20012[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation azureSubscriptionListForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionListForOrgAsync($org_name)
    {
        return $this->azureSubscriptionListForOrgAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation azureSubscriptionListForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionListForOrgAsyncWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012[]';
        $request = $this->azureSubscriptionListForOrgRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'azureSubscriptionListForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function azureSubscriptionListForOrgRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling azureSubscriptionListForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/azure_subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation azureSubscriptionListForUser
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20012[]
     */
    public function azureSubscriptionListForUser()
    {
        list($response) = $this->azureSubscriptionListForUserWithHttpInfo();
        return $response;
    }

    /**
     * Operation azureSubscriptionListForUserWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20012[], HTTP status code, HTTP response headers (array of strings)
     */
    public function azureSubscriptionListForUserWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012[]';
        $request = $this->azureSubscriptionListForUserRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20012[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation azureSubscriptionListForUserAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionListForUserAsync()
    {
        return $this->azureSubscriptionListForUserAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation azureSubscriptionListForUserAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function azureSubscriptionListForUserAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20012[]';
        $request = $this->azureSubscriptionListForUserRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'azureSubscriptionListForUser'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function azureSubscriptionListForUserRequest()
    {

        $resourcePath = '/v0.1/azure_subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupInvitationsAcceptAll
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupInvitationsAcceptAll()
    {
        $this->distributionGroupInvitationsAcceptAllWithHttpInfo();
    }

    /**
     * Operation distributionGroupInvitationsAcceptAllWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupInvitationsAcceptAllWithHttpInfo()
    {
        $returnType = '';
        $request = $this->distributionGroupInvitationsAcceptAllRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupInvitationsAcceptAllAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupInvitationsAcceptAllAsync()
    {
        return $this->distributionGroupInvitationsAcceptAllAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupInvitationsAcceptAllAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupInvitationsAcceptAllAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->distributionGroupInvitationsAcceptAllRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupInvitationsAcceptAll'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupInvitationsAcceptAllRequest()
    {

        $resourcePath = '/v0.1/user/invitations/distribution_groups/accept';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsAddApps
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps1 $apps The name of the apps to be added to the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsAddApps($org_name, $distribution_group_name, $apps)
    {
        $this->distributionGroupsAddAppsWithHttpInfo($org_name, $distribution_group_name, $apps);
    }

    /**
     * Operation distributionGroupsAddAppsWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps1 $apps The name of the apps to be added to the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsAddAppsWithHttpInfo($org_name, $distribution_group_name, $apps)
    {
        $returnType = '';
        $request = $this->distributionGroupsAddAppsRequest($org_name, $distribution_group_name, $apps);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsAddAppsAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps1 $apps The name of the apps to be added to the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsAddAppsAsync($org_name, $distribution_group_name, $apps)
    {
        return $this->distributionGroupsAddAppsAsyncWithHttpInfo($org_name, $distribution_group_name, $apps)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsAddAppsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps1 $apps The name of the apps to be added to the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsAddAppsAsyncWithHttpInfo($org_name, $distribution_group_name, $apps)
    {
        $returnType = '';
        $request = $this->distributionGroupsAddAppsRequest($org_name, $distribution_group_name, $apps);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsAddApps'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps1 $apps The name of the apps to be added to the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsAddAppsRequest($org_name, $distribution_group_name, $apps)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsAddApps'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsAddApps'
            );
        }
        // verify the required parameter 'apps' is set
        if ($apps === null || (is_array($apps) && count($apps) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apps when calling distributionGroupsAddApps'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($apps)) {
            $_tempBody = $apps;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsAddUser
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members4 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20011[]
     */
    public function distributionGroupsAddUser($owner_name, $app_name, $distribution_group_name, $members)
    {
        list($response) = $this->distributionGroupsAddUserWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members);
        return $response;
    }

    /**
     * Operation distributionGroupsAddUserWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members4 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20011[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsAddUserWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20011[]';
        $request = $this->distributionGroupsAddUserRequest($owner_name, $app_name, $distribution_group_name, $members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20011[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsAddUserAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members4 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsAddUserAsync($owner_name, $app_name, $distribution_group_name, $members)
    {
        return $this->distributionGroupsAddUserAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsAddUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members4 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsAddUserAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20011[]';
        $request = $this->distributionGroupsAddUserRequest($owner_name, $app_name, $distribution_group_name, $members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsAddUser'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members4 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsAddUserRequest($owner_name, $app_name, $distribution_group_name, $members)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsAddUser'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsAddUser'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsAddUser'
            );
        }
        // verify the required parameter 'members' is set
        if ($members === null || (is_array($members) && count($members) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $members when calling distributionGroupsAddUser'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($members)) {
            $_tempBody = $members;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsAddUsersForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\MemberEmails $member_emails list of user email addresses that should get added as members to the specified group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20011[]
     */
    public function distributionGroupsAddUsersForOrg($org_name, $distribution_group_name, $member_emails)
    {
        list($response) = $this->distributionGroupsAddUsersForOrgWithHttpInfo($org_name, $distribution_group_name, $member_emails);
        return $response;
    }

    /**
     * Operation distributionGroupsAddUsersForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\MemberEmails $member_emails list of user email addresses that should get added as members to the specified group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20011[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsAddUsersForOrgWithHttpInfo($org_name, $distribution_group_name, $member_emails)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20011[]';
        $request = $this->distributionGroupsAddUsersForOrgRequest($org_name, $distribution_group_name, $member_emails);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20011[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsAddUsersForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\MemberEmails $member_emails list of user email addresses that should get added as members to the specified group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsAddUsersForOrgAsync($org_name, $distribution_group_name, $member_emails)
    {
        return $this->distributionGroupsAddUsersForOrgAsyncWithHttpInfo($org_name, $distribution_group_name, $member_emails)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsAddUsersForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\MemberEmails $member_emails list of user email addresses that should get added as members to the specified group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsAddUsersForOrgAsyncWithHttpInfo($org_name, $distribution_group_name, $member_emails)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20011[]';
        $request = $this->distributionGroupsAddUsersForOrgRequest($org_name, $distribution_group_name, $member_emails);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsAddUsersForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\MemberEmails $member_emails list of user email addresses that should get added as members to the specified group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsAddUsersForOrgRequest($org_name, $distribution_group_name, $member_emails)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsAddUsersForOrg'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsAddUsersForOrg'
            );
        }
        // verify the required parameter 'member_emails' is set
        if ($member_emails === null || (is_array($member_emails) && count($member_emails) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $member_emails when calling distributionGroupsAddUsersForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($member_emails)) {
            $_tempBody = $member_emails;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsBulkDeleteApps
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps $apps The name of the apps to be deleted from the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsBulkDeleteApps($org_name, $distribution_group_name, $apps)
    {
        $this->distributionGroupsBulkDeleteAppsWithHttpInfo($org_name, $distribution_group_name, $apps);
    }

    /**
     * Operation distributionGroupsBulkDeleteAppsWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps $apps The name of the apps to be deleted from the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsBulkDeleteAppsWithHttpInfo($org_name, $distribution_group_name, $apps)
    {
        $returnType = '';
        $request = $this->distributionGroupsBulkDeleteAppsRequest($org_name, $distribution_group_name, $apps);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsBulkDeleteAppsAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps $apps The name of the apps to be deleted from the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsBulkDeleteAppsAsync($org_name, $distribution_group_name, $apps)
    {
        return $this->distributionGroupsBulkDeleteAppsAsyncWithHttpInfo($org_name, $distribution_group_name, $apps)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsBulkDeleteAppsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps $apps The name of the apps to be deleted from the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsBulkDeleteAppsAsyncWithHttpInfo($org_name, $distribution_group_name, $apps)
    {
        $returnType = '';
        $request = $this->distributionGroupsBulkDeleteAppsRequest($org_name, $distribution_group_name, $apps);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsBulkDeleteApps'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Apps $apps The name of the apps to be deleted from the distribution group. The apps have to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsBulkDeleteAppsRequest($org_name, $distribution_group_name, $apps)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsBulkDeleteApps'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsBulkDeleteApps'
            );
        }
        // verify the required parameter 'apps' is set
        if ($apps === null || (is_array($apps) && count($apps) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apps when calling distributionGroupsBulkDeleteApps'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps/bulk_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($apps)) {
            $_tempBody = $apps;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsBulkDeleteUsers
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members1 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsBulkDeleteUsers($org_name, $distribution_group_name, $members)
    {
        $this->distributionGroupsBulkDeleteUsersWithHttpInfo($org_name, $distribution_group_name, $members);
    }

    /**
     * Operation distributionGroupsBulkDeleteUsersWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members1 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsBulkDeleteUsersWithHttpInfo($org_name, $distribution_group_name, $members)
    {
        $returnType = '';
        $request = $this->distributionGroupsBulkDeleteUsersRequest($org_name, $distribution_group_name, $members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsBulkDeleteUsersAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members1 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsBulkDeleteUsersAsync($org_name, $distribution_group_name, $members)
    {
        return $this->distributionGroupsBulkDeleteUsersAsyncWithHttpInfo($org_name, $distribution_group_name, $members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsBulkDeleteUsersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members1 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsBulkDeleteUsersAsyncWithHttpInfo($org_name, $distribution_group_name, $members)
    {
        $returnType = '';
        $request = $this->distributionGroupsBulkDeleteUsersRequest($org_name, $distribution_group_name, $members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsBulkDeleteUsers'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members1 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsBulkDeleteUsersRequest($org_name, $distribution_group_name, $members)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsBulkDeleteUsers'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsBulkDeleteUsers'
            );
        }
        // verify the required parameter 'members' is set
        if ($members === null || (is_array($members) && count($members) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $members when calling distributionGroupsBulkDeleteUsers'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members/bulk_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($members)) {
            $_tempBody = $members;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsCreate
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DistributionGroup3 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function distributionGroupsCreate($owner_name, $app_name, $distribution_group)
    {
        list($response) = $this->distributionGroupsCreateWithHttpInfo($owner_name, $app_name, $distribution_group);
        return $response;
    }

    /**
     * Operation distributionGroupsCreateWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DistributionGroup3 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsCreateWithHttpInfo($owner_name, $app_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsCreateRequest($owner_name, $app_name, $distribution_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsCreateAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DistributionGroup3 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsCreateAsync($owner_name, $app_name, $distribution_group)
    {
        return $this->distributionGroupsCreateAsyncWithHttpInfo($owner_name, $app_name, $distribution_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DistributionGroup3 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsCreateAsyncWithHttpInfo($owner_name, $app_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsCreateRequest($owner_name, $app_name, $distribution_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsCreate'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DistributionGroup3 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsCreateRequest($owner_name, $app_name, $distribution_group)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsCreate'
            );
        }
        // verify the required parameter 'distribution_group' is set
        if ($distribution_group === null || (is_array($distribution_group) && count($distribution_group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group when calling distributionGroupsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($distribution_group)) {
            $_tempBody = $distribution_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsCreateForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\DistributionGroup1 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function distributionGroupsCreateForOrg($org_name, $distribution_group)
    {
        list($response) = $this->distributionGroupsCreateForOrgWithHttpInfo($org_name, $distribution_group);
        return $response;
    }

    /**
     * Operation distributionGroupsCreateForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\DistributionGroup1 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsCreateForOrgWithHttpInfo($org_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsCreateForOrgRequest($org_name, $distribution_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsCreateForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\DistributionGroup1 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsCreateForOrgAsync($org_name, $distribution_group)
    {
        return $this->distributionGroupsCreateForOrgAsyncWithHttpInfo($org_name, $distribution_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsCreateForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\DistributionGroup1 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsCreateForOrgAsyncWithHttpInfo($org_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsCreateForOrgRequest($org_name, $distribution_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsCreateForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\DistributionGroup1 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsCreateForOrgRequest($org_name, $distribution_group)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsCreateForOrg'
            );
        }
        // verify the required parameter 'distribution_group' is set
        if ($distribution_group === null || (is_array($distribution_group) && count($distribution_group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group when calling distributionGroupsCreateForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($distribution_group)) {
            $_tempBody = $distribution_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsDelete
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsDelete($app_name, $owner_name, $distribution_group_name)
    {
        $this->distributionGroupsDeleteWithHttpInfo($app_name, $owner_name, $distribution_group_name);
    }

    /**
     * Operation distributionGroupsDeleteWithHttpInfo
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsDeleteWithHttpInfo($app_name, $owner_name, $distribution_group_name)
    {
        $returnType = '';
        $request = $this->distributionGroupsDeleteRequest($app_name, $owner_name, $distribution_group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsDeleteAsync
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsDeleteAsync($app_name, $owner_name, $distribution_group_name)
    {
        return $this->distributionGroupsDeleteAsyncWithHttpInfo($app_name, $owner_name, $distribution_group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsDeleteAsyncWithHttpInfo($app_name, $owner_name, $distribution_group_name)
    {
        $returnType = '';
        $request = $this->distributionGroupsDeleteRequest($app_name, $owner_name, $distribution_group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsDelete'
     *
     * @param  string $app_name The name of the application (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsDeleteRequest($app_name, $owner_name, $distribution_group_name)
    {
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsDelete'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsDeleteForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsDeleteForOrg($org_name, $distribution_group_name)
    {
        $this->distributionGroupsDeleteForOrgWithHttpInfo($org_name, $distribution_group_name);
    }

    /**
     * Operation distributionGroupsDeleteForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsDeleteForOrgWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = '';
        $request = $this->distributionGroupsDeleteForOrgRequest($org_name, $distribution_group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsDeleteForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsDeleteForOrgAsync($org_name, $distribution_group_name)
    {
        return $this->distributionGroupsDeleteForOrgAsyncWithHttpInfo($org_name, $distribution_group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsDeleteForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsDeleteForOrgAsyncWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = '';
        $request = $this->distributionGroupsDeleteForOrgRequest($org_name, $distribution_group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsDeleteForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsDeleteForOrgRequest($org_name, $distribution_group_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsDeleteForOrg'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsDeleteForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsDetailsForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  float $apps_limit The max number of apps to include in the response (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function distributionGroupsDetailsForOrg($org_name, $apps_limit = null)
    {
        list($response) = $this->distributionGroupsDetailsForOrgWithHttpInfo($org_name, $apps_limit);
        return $response;
    }

    /**
     * Operation distributionGroupsDetailsForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  float $apps_limit The max number of apps to include in the response (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsDetailsForOrgWithHttpInfo($org_name, $apps_limit = null)
    {
        $returnType = 'object[]';
        $request = $this->distributionGroupsDetailsForOrgRequest($org_name, $apps_limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsDetailsForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  float $apps_limit The max number of apps to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsDetailsForOrgAsync($org_name, $apps_limit = null)
    {
        return $this->distributionGroupsDetailsForOrgAsyncWithHttpInfo($org_name, $apps_limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsDetailsForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  float $apps_limit The max number of apps to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsDetailsForOrgAsyncWithHttpInfo($org_name, $apps_limit = null)
    {
        $returnType = 'object[]';
        $request = $this->distributionGroupsDetailsForOrgRequest($org_name, $apps_limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsDetailsForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  float $apps_limit The max number of apps to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsDetailsForOrgRequest($org_name, $apps_limit = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsDetailsForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups_details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apps_limit !== null) {
            $queryParams['apps_limit'] = ObjectSerializer::toQueryValue($apps_limit);
        }

        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsGet
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function distributionGroupsGet($owner_name, $app_name, $distribution_group_name)
    {
        list($response) = $this->distributionGroupsGetWithHttpInfo($owner_name, $app_name, $distribution_group_name);
        return $response;
    }

    /**
     * Operation distributionGroupsGetWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsGetWithHttpInfo($owner_name, $app_name, $distribution_group_name)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsGetRequest($owner_name, $app_name, $distribution_group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsGetAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsGetAsync($owner_name, $app_name, $distribution_group_name)
    {
        return $this->distributionGroupsGetAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsGetAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsGetRequest($owner_name, $app_name, $distribution_group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsGet'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsGetRequest($owner_name, $app_name, $distribution_group_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsGet'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsGetApps
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function distributionGroupsGetApps($org_name, $distribution_group_name)
    {
        list($response) = $this->distributionGroupsGetAppsWithHttpInfo($org_name, $distribution_group_name);
        return $response;
    }

    /**
     * Operation distributionGroupsGetAppsWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsGetAppsWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = 'object[]';
        $request = $this->distributionGroupsGetAppsRequest($org_name, $distribution_group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsGetAppsAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsGetAppsAsync($org_name, $distribution_group_name)
    {
        return $this->distributionGroupsGetAppsAsyncWithHttpInfo($org_name, $distribution_group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsGetAppsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsGetAppsAsyncWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = 'object[]';
        $request = $this->distributionGroupsGetAppsRequest($org_name, $distribution_group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsGetApps'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsGetAppsRequest($org_name, $distribution_group_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsGetApps'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsGetApps'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsGetForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function distributionGroupsGetForOrg($org_name, $distribution_group_name)
    {
        list($response) = $this->distributionGroupsGetForOrgWithHttpInfo($org_name, $distribution_group_name);
        return $response;
    }

    /**
     * Operation distributionGroupsGetForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsGetForOrgWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsGetForOrgRequest($org_name, $distribution_group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsGetForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsGetForOrgAsync($org_name, $distribution_group_name)
    {
        return $this->distributionGroupsGetForOrgAsyncWithHttpInfo($org_name, $distribution_group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsGetForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsGetForOrgAsyncWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsGetForOrgRequest($org_name, $distribution_group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsGetForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsGetForOrgRequest($org_name, $distribution_group_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsGetForOrg'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsGetForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse201[]
     */
    public function distributionGroupsList($owner_name, $app_name)
    {
        list($response) = $this->distributionGroupsListWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation distributionGroupsListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse201[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsListWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse201[]';
        $request = $this->distributionGroupsListRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse201[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListAsync($owner_name, $app_name)
    {
        return $this->distributionGroupsListAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse201[]';
        $request = $this->distributionGroupsListRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsListRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsListAllTestersForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2007[]
     */
    public function distributionGroupsListAllTestersForOrg($org_name)
    {
        list($response) = $this->distributionGroupsListAllTestersForOrgWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation distributionGroupsListAllTestersForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2007[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsListAllTestersForOrgWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2007[]';
        $request = $this->distributionGroupsListAllTestersForOrgRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2007[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsListAllTestersForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListAllTestersForOrgAsync($org_name)
    {
        return $this->distributionGroupsListAllTestersForOrgAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsListAllTestersForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListAllTestersForOrgAsyncWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2007[]';
        $request = $this->distributionGroupsListAllTestersForOrgRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsListAllTestersForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsListAllTestersForOrgRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsListAllTestersForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/testers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsListForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse201[]
     */
    public function distributionGroupsListForOrg($org_name)
    {
        list($response) = $this->distributionGroupsListForOrgWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation distributionGroupsListForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse201[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsListForOrgWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse201[]';
        $request = $this->distributionGroupsListForOrgRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse201[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsListForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListForOrgAsync($org_name)
    {
        return $this->distributionGroupsListForOrgAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsListForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListForOrgAsyncWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse201[]';
        $request = $this->distributionGroupsListForOrgRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsListForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsListForOrgRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsListForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsListUsers
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  bool $exclude_pending_invitations Whether to exclude pending invitations in the response (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20010[]
     */
    public function distributionGroupsListUsers($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations = null)
    {
        list($response) = $this->distributionGroupsListUsersWithHttpInfo($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations);
        return $response;
    }

    /**
     * Operation distributionGroupsListUsersWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  bool $exclude_pending_invitations Whether to exclude pending invitations in the response (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20010[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsListUsersWithHttpInfo($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20010[]';
        $request = $this->distributionGroupsListUsersRequest($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20010[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsListUsersAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  bool $exclude_pending_invitations Whether to exclude pending invitations in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListUsersAsync($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations = null)
    {
        return $this->distributionGroupsListUsersAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsListUsersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  bool $exclude_pending_invitations Whether to exclude pending invitations in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListUsersAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20010[]';
        $request = $this->distributionGroupsListUsersRequest($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsListUsers'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  bool $exclude_pending_invitations Whether to exclude pending invitations in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsListUsersRequest($owner_name, $app_name, $distribution_group_name, $exclude_pending_invitations = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsListUsers'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsListUsers'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsListUsers'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($exclude_pending_invitations !== null) {
            $queryParams['exclude_pending_invitations'] = ObjectSerializer::toQueryValue($exclude_pending_invitations);
        }

        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsListUsersForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20010[]
     */
    public function distributionGroupsListUsersForOrg($org_name, $distribution_group_name)
    {
        list($response) = $this->distributionGroupsListUsersForOrgWithHttpInfo($org_name, $distribution_group_name);
        return $response;
    }

    /**
     * Operation distributionGroupsListUsersForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20010[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsListUsersForOrgWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20010[]';
        $request = $this->distributionGroupsListUsersForOrgRequest($org_name, $distribution_group_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20010[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsListUsersForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListUsersForOrgAsync($org_name, $distribution_group_name)
    {
        return $this->distributionGroupsListUsersForOrgAsyncWithHttpInfo($org_name, $distribution_group_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsListUsersForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsListUsersForOrgAsyncWithHttpInfo($org_name, $distribution_group_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20010[]';
        $request = $this->distributionGroupsListUsersForOrgRequest($org_name, $distribution_group_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsListUsersForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsListUsersForOrgRequest($org_name, $distribution_group_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsListUsersForOrg'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsListUsersForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsPatchForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function distributionGroupsPatchForOrg($org_name, $distribution_group_name, $distribution_group)
    {
        list($response) = $this->distributionGroupsPatchForOrgWithHttpInfo($org_name, $distribution_group_name, $distribution_group);
        return $response;
    }

    /**
     * Operation distributionGroupsPatchForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsPatchForOrgWithHttpInfo($org_name, $distribution_group_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsPatchForOrgRequest($org_name, $distribution_group_name, $distribution_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsPatchForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsPatchForOrgAsync($org_name, $distribution_group_name, $distribution_group)
    {
        return $this->distributionGroupsPatchForOrgAsyncWithHttpInfo($org_name, $distribution_group_name, $distribution_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsPatchForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsPatchForOrgAsyncWithHttpInfo($org_name, $distribution_group_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsPatchForOrgRequest($org_name, $distribution_group_name, $distribution_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsPatchForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsPatchForOrgRequest($org_name, $distribution_group_name, $distribution_group)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsPatchForOrg'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsPatchForOrg'
            );
        }
        // verify the required parameter 'distribution_group' is set
        if ($distribution_group === null || (is_array($distribution_group) && count($distribution_group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group when calling distributionGroupsPatchForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($distribution_group)) {
            $_tempBody = $distribution_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsRemoveUser
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members3 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20063[]
     */
    public function distributionGroupsRemoveUser($owner_name, $app_name, $distribution_group_name, $members)
    {
        list($response) = $this->distributionGroupsRemoveUserWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members);
        return $response;
    }

    /**
     * Operation distributionGroupsRemoveUserWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members3 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20063[], HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsRemoveUserWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20063[]';
        $request = $this->distributionGroupsRemoveUserRequest($owner_name, $app_name, $distribution_group_name, $members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20063[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsRemoveUserAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members3 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsRemoveUserAsync($owner_name, $app_name, $distribution_group_name, $members)
    {
        return $this->distributionGroupsRemoveUserAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsRemoveUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members3 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsRemoveUserAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20063[]';
        $request = $this->distributionGroupsRemoveUserRequest($owner_name, $app_name, $distribution_group_name, $members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsRemoveUser'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members3 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsRemoveUserRequest($owner_name, $app_name, $distribution_group_name, $members)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsRemoveUser'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsRemoveUser'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsRemoveUser'
            );
        }
        // verify the required parameter 'members' is set
        if ($members === null || (is_array($members) && count($members) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $members when calling distributionGroupsRemoveUser'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members/bulk_delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($members)) {
            $_tempBody = $members;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsResendInvite
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members2 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsResendInvite($owner_name, $app_name, $distribution_group_name, $members)
    {
        $this->distributionGroupsResendInviteWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members);
    }

    /**
     * Operation distributionGroupsResendInviteWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members2 $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsResendInviteWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
    {
        $returnType = '';
        $request = $this->distributionGroupsResendInviteRequest($owner_name, $app_name, $distribution_group_name, $members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsResendInviteAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members2 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsResendInviteAsync($owner_name, $app_name, $distribution_group_name, $members)
    {
        return $this->distributionGroupsResendInviteAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsResendInviteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members2 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsResendInviteAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $members)
    {
        $returnType = '';
        $request = $this->distributionGroupsResendInviteRequest($owner_name, $app_name, $distribution_group_name, $members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsResendInvite'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members2 $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsResendInviteRequest($owner_name, $app_name, $distribution_group_name, $members)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsResendInvite'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsResendInvite'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsResendInvite'
            );
        }
        // verify the required parameter 'members' is set
        if ($members === null || (is_array($members) && count($members) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $members when calling distributionGroupsResendInvite'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/resend_invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($members)) {
            $_tempBody = $members;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsResendSharedInvite
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distributionGroupsResendSharedInvite($org_name, $distribution_group_name, $members)
    {
        $this->distributionGroupsResendSharedInviteWithHttpInfo($org_name, $distribution_group_name, $members);
    }

    /**
     * Operation distributionGroupsResendSharedInviteWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members $members The list of members to add (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsResendSharedInviteWithHttpInfo($org_name, $distribution_group_name, $members)
    {
        $returnType = '';
        $request = $this->distributionGroupsResendSharedInviteRequest($org_name, $distribution_group_name, $members);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsResendSharedInviteAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsResendSharedInviteAsync($org_name, $distribution_group_name, $members)
    {
        return $this->distributionGroupsResendSharedInviteAsyncWithHttpInfo($org_name, $distribution_group_name, $members)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsResendSharedInviteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsResendSharedInviteAsyncWithHttpInfo($org_name, $distribution_group_name, $members)
    {
        $returnType = '';
        $request = $this->distributionGroupsResendSharedInviteRequest($org_name, $distribution_group_name, $members);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsResendSharedInvite'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\Members $members The list of members to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsResendSharedInviteRequest($org_name, $distribution_group_name, $members)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling distributionGroupsResendSharedInvite'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsResendSharedInvite'
            );
        }
        // verify the required parameter 'members' is set
        if ($members === null || (is_array($members) && count($members) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $members when calling distributionGroupsResendSharedInvite'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/resend_invite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($members)) {
            $_tempBody = $members;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distributionGroupsUpdate
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup2 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function distributionGroupsUpdate($owner_name, $app_name, $distribution_group_name, $distribution_group)
    {
        list($response) = $this->distributionGroupsUpdateWithHttpInfo($owner_name, $app_name, $distribution_group_name, $distribution_group);
        return $response;
    }

    /**
     * Operation distributionGroupsUpdateWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup2 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function distributionGroupsUpdateWithHttpInfo($owner_name, $app_name, $distribution_group_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsUpdateRequest($owner_name, $app_name, $distribution_group_name, $distribution_group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation distributionGroupsUpdateAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup2 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsUpdateAsync($owner_name, $app_name, $distribution_group_name, $distribution_group)
    {
        return $this->distributionGroupsUpdateAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $distribution_group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distributionGroupsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup2 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distributionGroupsUpdateAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $distribution_group)
    {
        $returnType = 'object';
        $request = $this->distributionGroupsUpdateRequest($owner_name, $app_name, $distribution_group_name, $distribution_group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distributionGroupsUpdate'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $distribution_group_name The name of the distribution group (required)
     * @param  \Swagger\Client\Model\DistributionGroup2 $distribution_group The attributes to update for the distribution group (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distributionGroupsUpdateRequest($owner_name, $app_name, $distribution_group_name, $distribution_group)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distributionGroupsUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distributionGroupsUpdate'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling distributionGroupsUpdate'
            );
        }
        // verify the required parameter 'distribution_group' is set
        if ($distribution_group === null || (is_array($distribution_group) && count($distribution_group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group when calling distributionGroupsUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($distribution_group)) {
            $_tempBody = $distribution_group;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation invitationsSent
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20015[]
     */
    public function invitationsSent()
    {
        list($response) = $this->invitationsSentWithHttpInfo();
        return $response;
    }

    /**
     * Operation invitationsSentWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20015[], HTTP status code, HTTP response headers (array of strings)
     */
    public function invitationsSentWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20015[]';
        $request = $this->invitationsSentRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20015[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation invitationsSentAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invitationsSentAsync()
    {
        return $this->invitationsSentAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation invitationsSentAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function invitationsSentAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20015[]';
        $request = $this->invitationsSentRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'invitationsSent'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function invitationsSentRequest()
    {

        $resourcePath = '/v0.1/invitations/sent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitations
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitations($org_name, $email)
    {
        $this->orgInvitationsWithHttpInfo($org_name, $email);
    }

    /**
     * Operation orgInvitationsWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsWithHttpInfo($org_name, $email)
    {
        $returnType = '';
        $request = $this->orgInvitationsRequest($org_name, $email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsAsync($org_name, $email)
    {
        return $this->orgInvitationsAsyncWithHttpInfo($org_name, $email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsAsyncWithHttpInfo($org_name, $email)
    {
        $returnType = '';
        $request = $this->orgInvitationsRequest($org_name, $email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitations'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsRequest($org_name, $email)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling orgInvitations'
            );
        }
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling orgInvitations'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/invitations/{email}/revoke';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($email !== null) {
            $resourcePath = str_replace(
                '{' . 'email' . '}',
                ObjectSerializer::toPathValue($email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsAccept
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitationsAccept($invitation_token)
    {
        $this->orgInvitationsAcceptWithHttpInfo($invitation_token);
    }

    /**
     * Operation orgInvitationsAcceptWithHttpInfo
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsAcceptWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->orgInvitationsAcceptRequest($invitation_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsAcceptAsync
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsAcceptAsync($invitation_token)
    {
        return $this->orgInvitationsAcceptAsyncWithHttpInfo($invitation_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsAcceptAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsAcceptAsyncWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->orgInvitationsAcceptRequest($invitation_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsAccept'
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsAcceptRequest($invitation_token)
    {
        // verify the required parameter 'invitation_token' is set
        if ($invitation_token === null || (is_array($invitation_token) && count($invitation_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invitation_token when calling orgInvitationsAccept'
            );
        }

        $resourcePath = '/v0.1/user/invitations/orgs/{invitation_token}/accept';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invitation_token !== null) {
            $resourcePath = str_replace(
                '{' . 'invitation_token' . '}',
                ObjectSerializer::toPathValue($invitation_token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsCreate
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail1 $user_email The email of the user to invite (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitationsCreate($org_name, $user_email = null)
    {
        $this->orgInvitationsCreateWithHttpInfo($org_name, $user_email);
    }

    /**
     * Operation orgInvitationsCreateWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail1 $user_email The email of the user to invite (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsCreateWithHttpInfo($org_name, $user_email = null)
    {
        $returnType = '';
        $request = $this->orgInvitationsCreateRequest($org_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsCreateAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail1 $user_email The email of the user to invite (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsCreateAsync($org_name, $user_email = null)
    {
        return $this->orgInvitationsCreateAsyncWithHttpInfo($org_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail1 $user_email The email of the user to invite (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsCreateAsyncWithHttpInfo($org_name, $user_email = null)
    {
        $returnType = '';
        $request = $this->orgInvitationsCreateRequest($org_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsCreate'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail1 $user_email The email of the user to invite (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsCreateRequest($org_name, $user_email = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling orgInvitationsCreate'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_email)) {
            $_tempBody = $user_email;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsDelete
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail2 $user_email The email of the user whose invitation should be removed (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitationsDelete($org_name, $user_email = null)
    {
        $this->orgInvitationsDeleteWithHttpInfo($org_name, $user_email);
    }

    /**
     * Operation orgInvitationsDeleteWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail2 $user_email The email of the user whose invitation should be removed (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsDeleteWithHttpInfo($org_name, $user_email = null)
    {
        $returnType = '';
        $request = $this->orgInvitationsDeleteRequest($org_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsDeleteAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail2 $user_email The email of the user whose invitation should be removed (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsDeleteAsync($org_name, $user_email = null)
    {
        return $this->orgInvitationsDeleteAsyncWithHttpInfo($org_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail2 $user_email The email of the user whose invitation should be removed (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsDeleteAsyncWithHttpInfo($org_name, $user_email = null)
    {
        $returnType = '';
        $request = $this->orgInvitationsDeleteRequest($org_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsDelete'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail2 $user_email The email of the user whose invitation should be removed (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsDeleteRequest($org_name, $user_email = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling orgInvitationsDelete'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_email)) {
            $_tempBody = $user_email;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsListPending
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2009[]
     */
    public function orgInvitationsListPending($org_name)
    {
        list($response) = $this->orgInvitationsListPendingWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation orgInvitationsListPendingWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2009[], HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsListPendingWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2009[]';
        $request = $this->orgInvitationsListPendingRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2009[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsListPendingAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsListPendingAsync($org_name)
    {
        return $this->orgInvitationsListPendingAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsListPendingAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsListPendingAsyncWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2009[]';
        $request = $this->orgInvitationsListPendingRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsListPending'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsListPendingRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling orgInvitationsListPending'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsReject
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitationsReject($invitation_token)
    {
        $this->orgInvitationsRejectWithHttpInfo($invitation_token);
    }

    /**
     * Operation orgInvitationsRejectWithHttpInfo
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsRejectWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->orgInvitationsRejectRequest($invitation_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsRejectAsync
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsRejectAsync($invitation_token)
    {
        return $this->orgInvitationsRejectAsyncWithHttpInfo($invitation_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsRejectAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsRejectAsyncWithHttpInfo($invitation_token)
    {
        $returnType = '';
        $request = $this->orgInvitationsRejectRequest($invitation_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsReject'
     *
     * @param  string $invitation_token The app invitation token that was sent to the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsRejectRequest($invitation_token)
    {
        // verify the required parameter 'invitation_token' is set
        if ($invitation_token === null || (is_array($invitation_token) && count($invitation_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invitation_token when calling orgInvitationsReject'
            );
        }

        $resourcePath = '/v0.1/user/invitations/orgs/{invitation_token}/reject';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($invitation_token !== null) {
            $resourcePath = str_replace(
                '{' . 'invitation_token' . '}',
                ObjectSerializer::toPathValue($invitation_token),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsSendNewInvitation
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\Role $role The role of the user to be added (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitationsSendNewInvitation($org_name, $email, $role = null)
    {
        $this->orgInvitationsSendNewInvitationWithHttpInfo($org_name, $email, $role);
    }

    /**
     * Operation orgInvitationsSendNewInvitationWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\Role $role The role of the user to be added (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsSendNewInvitationWithHttpInfo($org_name, $email, $role = null)
    {
        $returnType = '';
        $request = $this->orgInvitationsSendNewInvitationRequest($org_name, $email, $role);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsSendNewInvitationAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\Role $role The role of the user to be added (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsSendNewInvitationAsync($org_name, $email, $role = null)
    {
        return $this->orgInvitationsSendNewInvitationAsyncWithHttpInfo($org_name, $email, $role)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsSendNewInvitationAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\Role $role The role of the user to be added (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsSendNewInvitationAsyncWithHttpInfo($org_name, $email, $role = null)
    {
        $returnType = '';
        $request = $this->orgInvitationsSendNewInvitationRequest($org_name, $email, $role);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsSendNewInvitation'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\Role $role The role of the user to be added (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsSendNewInvitationRequest($org_name, $email, $role = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling orgInvitationsSendNewInvitation'
            );
        }
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling orgInvitationsSendNewInvitation'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/invitations/{email}/resend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($email !== null) {
            $resourcePath = str_replace(
                '{' . 'email' . '}',
                ObjectSerializer::toPathValue($email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($role)) {
            $_tempBody = $role;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orgInvitationsUpdate
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\UserRole $user_role The new role of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function orgInvitationsUpdate($org_name, $email, $user_role)
    {
        $this->orgInvitationsUpdateWithHttpInfo($org_name, $email, $user_role);
    }

    /**
     * Operation orgInvitationsUpdateWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\UserRole $user_role The new role of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function orgInvitationsUpdateWithHttpInfo($org_name, $email, $user_role)
    {
        $returnType = '';
        $request = $this->orgInvitationsUpdateRequest($org_name, $email, $user_role);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation orgInvitationsUpdateAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\UserRole $user_role The new role of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsUpdateAsync($org_name, $email, $user_role)
    {
        return $this->orgInvitationsUpdateAsyncWithHttpInfo($org_name, $email, $user_role)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation orgInvitationsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\UserRole $user_role The new role of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function orgInvitationsUpdateAsyncWithHttpInfo($org_name, $email, $user_role)
    {
        $returnType = '';
        $request = $this->orgInvitationsUpdateRequest($org_name, $email, $user_role);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'orgInvitationsUpdate'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $email The email address of the user to send the password reset mail to. (required)
     * @param  \Swagger\Client\Model\UserRole $user_role The new role of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function orgInvitationsUpdateRequest($org_name, $email, $user_role)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling orgInvitationsUpdate'
            );
        }
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling orgInvitationsUpdate'
            );
        }
        // verify the required parameter 'user_role' is set
        if ($user_role === null || (is_array($user_role) && count($user_role) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_role when calling orgInvitationsUpdate'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/invitations/{email}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($email !== null) {
            $resourcePath = str_replace(
                '{' . 'email' . '}',
                ObjectSerializer::toPathValue($email),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_role)) {
            $_tempBody = $user_role;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationDeleteAvatar
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function organizationDeleteAvatar($org_name)
    {
        list($response) = $this->organizationDeleteAvatarWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation organizationDeleteAvatarWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationDeleteAvatarWithHttpInfo($org_name)
    {
        $returnType = 'object';
        $request = $this->organizationDeleteAvatarRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationDeleteAvatarAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationDeleteAvatarAsync($org_name)
    {
        return $this->organizationDeleteAvatarAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationDeleteAvatarAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationDeleteAvatarAsyncWithHttpInfo($org_name)
    {
        $returnType = 'object';
        $request = $this->organizationDeleteAvatarRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationDeleteAvatar'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationDeleteAvatarRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling organizationDeleteAvatar'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationUpdateAvatar
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \SplFileObject $avatar The image for an Organization avatar to upload. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function organizationUpdateAvatar($org_name, $avatar = null)
    {
        list($response) = $this->organizationUpdateAvatarWithHttpInfo($org_name, $avatar);
        return $response;
    }

    /**
     * Operation organizationUpdateAvatarWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \SplFileObject $avatar The image for an Organization avatar to upload. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationUpdateAvatarWithHttpInfo($org_name, $avatar = null)
    {
        $returnType = 'object';
        $request = $this->organizationUpdateAvatarRequest($org_name, $avatar);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationUpdateAvatarAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \SplFileObject $avatar The image for an Organization avatar to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationUpdateAvatarAsync($org_name, $avatar = null)
    {
        return $this->organizationUpdateAvatarAsyncWithHttpInfo($org_name, $avatar)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationUpdateAvatarAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \SplFileObject $avatar The image for an Organization avatar to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationUpdateAvatarAsyncWithHttpInfo($org_name, $avatar = null)
    {
        $returnType = 'object';
        $request = $this->organizationUpdateAvatarRequest($org_name, $avatar);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationUpdateAvatar'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \SplFileObject $avatar The image for an Organization avatar to upload. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationUpdateAvatarRequest($org_name, $avatar = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling organizationUpdateAvatar'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/avatar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // form params
        if ($avatar !== null) {
            $multipart = true;
            $formParams['avatar'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($avatar), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationsCreateOrUpdate
     *
     * @param  \Swagger\Client\Model\Organization $organization The organization data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function organizationsCreateOrUpdate($organization)
    {
        list($response) = $this->organizationsCreateOrUpdateWithHttpInfo($organization);
        return $response;
    }

    /**
     * Operation organizationsCreateOrUpdateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\Organization $organization The organization data (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationsCreateOrUpdateWithHttpInfo($organization)
    {
        $returnType = 'object';
        $request = $this->organizationsCreateOrUpdateRequest($organization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationsCreateOrUpdateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\Organization $organization The organization data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsCreateOrUpdateAsync($organization)
    {
        return $this->organizationsCreateOrUpdateAsyncWithHttpInfo($organization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationsCreateOrUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\Organization $organization The organization data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsCreateOrUpdateAsyncWithHttpInfo($organization)
    {
        $returnType = 'object';
        $request = $this->organizationsCreateOrUpdateRequest($organization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationsCreateOrUpdate'
     *
     * @param  \Swagger\Client\Model\Organization $organization The organization data (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationsCreateOrUpdateRequest($organization)
    {
        // verify the required parameter 'organization' is set
        if ($organization === null || (is_array($organization) && count($organization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization when calling organizationsCreateOrUpdate'
            );
        }

        $resourcePath = '/v0.1/orgs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($organization)) {
            $_tempBody = $organization;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationsDelete
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function organizationsDelete($org_name)
    {
        $this->organizationsDeleteWithHttpInfo($org_name);
    }

    /**
     * Operation organizationsDeleteWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationsDeleteWithHttpInfo($org_name)
    {
        $returnType = '';
        $request = $this->organizationsDeleteRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationsDeleteAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsDeleteAsync($org_name)
    {
        return $this->organizationsDeleteAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsDeleteAsyncWithHttpInfo($org_name)
    {
        $returnType = '';
        $request = $this->organizationsDeleteRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationsDelete'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationsDeleteRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling organizationsDelete'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationsGet
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function organizationsGet($org_name)
    {
        list($response) = $this->organizationsGetWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation organizationsGetWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationsGetWithHttpInfo($org_name)
    {
        $returnType = 'object';
        $request = $this->organizationsGetRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationsGetAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsGetAsync($org_name)
    {
        return $this->organizationsGetAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsGetAsyncWithHttpInfo($org_name)
    {
        $returnType = 'object';
        $request = $this->organizationsGetRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationsGet'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationsGetRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling organizationsGet'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationsList
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20014[]
     */
    public function organizationsList()
    {
        list($response) = $this->organizationsListWithHttpInfo();
        return $response;
    }

    /**
     * Operation organizationsListWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20014[], HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationsListWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20014[]';
        $request = $this->organizationsListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20014[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationsListAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsListAsync()
    {
        return $this->organizationsListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationsListAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsListAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20014[]';
        $request = $this->organizationsListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationsList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationsListRequest()
    {

        $resourcePath = '/v0.1/orgs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationsListAdministered
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20099
     */
    public function organizationsListAdministered()
    {
        list($response) = $this->organizationsListAdministeredWithHttpInfo();
        return $response;
    }

    /**
     * Operation organizationsListAdministeredWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20099, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationsListAdministeredWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20099';
        $request = $this->organizationsListAdministeredRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20099',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationsListAdministeredAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsListAdministeredAsync()
    {
        return $this->organizationsListAdministeredAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationsListAdministeredAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsListAdministeredAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20099';
        $request = $this->organizationsListAdministeredRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationsListAdministered'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationsListAdministeredRequest()
    {

        $resourcePath = '/v0.1/administeredOrgs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation organizationsUpdate
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Org $org The data for the org (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function organizationsUpdate($org_name, $org)
    {
        list($response) = $this->organizationsUpdateWithHttpInfo($org_name, $org);
        return $response;
    }

    /**
     * Operation organizationsUpdateWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Org $org The data for the org (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function organizationsUpdateWithHttpInfo($org_name, $org)
    {
        $returnType = 'object';
        $request = $this->organizationsUpdateRequest($org_name, $org);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation organizationsUpdateAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Org $org The data for the org (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsUpdateAsync($org_name, $org)
    {
        return $this->organizationsUpdateAsyncWithHttpInfo($org_name, $org)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation organizationsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Org $org The data for the org (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function organizationsUpdateAsyncWithHttpInfo($org_name, $org)
    {
        $returnType = 'object';
        $request = $this->organizationsUpdateRequest($org_name, $org);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'organizationsUpdate'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Org $org The data for the org (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function organizationsUpdateRequest($org_name, $org)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling organizationsUpdate'
            );
        }
        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling organizationsUpdate'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($org)) {
            $_tempBody = $org;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sharedconnectionConnections
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001[]
     */
    public function sharedconnectionConnections()
    {
        list($response) = $this->sharedconnectionConnectionsWithHttpInfo();
        return $response;
    }

    /**
     * Operation sharedconnectionConnectionsWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001[], HTTP status code, HTTP response headers (array of strings)
     */
    public function sharedconnectionConnectionsWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001[]';
        $request = $this->sharedconnectionConnectionsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sharedconnectionConnectionsAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sharedconnectionConnectionsAsync()
    {
        return $this->sharedconnectionConnectionsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sharedconnectionConnectionsAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sharedconnectionConnectionsAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001[]';
        $request = $this->sharedconnectionConnectionsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sharedconnectionConnections'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sharedconnectionConnectionsRequest()
    {

        $resourcePath = '/v0.1/user/export/serviceConnections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddApp
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\App $app The name of the app to be added to the team. The app has to be owned by the organization. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function teamsAddApp($org_name, $team_name, $app)
    {
        list($response) = $this->teamsAddAppWithHttpInfo($org_name, $team_name, $app);
        return $response;
    }

    /**
     * Operation teamsAddAppWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\App $app The name of the app to be added to the team. The app has to be owned by the organization. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsAddAppWithHttpInfo($org_name, $team_name, $app)
    {
        $returnType = 'object';
        $request = $this->teamsAddAppRequest($org_name, $team_name, $app);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddAppAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\App $app The name of the app to be added to the team. The app has to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddAppAsync($org_name, $team_name, $app)
    {
        return $this->teamsAddAppAsyncWithHttpInfo($org_name, $team_name, $app)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddAppAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\App $app The name of the app to be added to the team. The app has to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddAppAsyncWithHttpInfo($org_name, $team_name, $app)
    {
        $returnType = 'object';
        $request = $this->teamsAddAppRequest($org_name, $team_name, $app);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddApp'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\App $app The name of the app to be added to the team. The app has to be owned by the organization. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsAddAppRequest($org_name, $team_name, $app)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsAddApp'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsAddApp'
            );
        }
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling teamsAddApp'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($app)) {
            $_tempBody = $app;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddUser
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail $user_email The email of the user to add to the team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function teamsAddUser($org_name, $team_name, $user_email = null)
    {
        list($response) = $this->teamsAddUserWithHttpInfo($org_name, $team_name, $user_email);
        return $response;
    }

    /**
     * Operation teamsAddUserWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail $user_email The email of the user to add to the team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsAddUserWithHttpInfo($org_name, $team_name, $user_email = null)
    {
        $returnType = 'object';
        $request = $this->teamsAddUserRequest($org_name, $team_name, $user_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddUserAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail $user_email The email of the user to add to the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddUserAsync($org_name, $team_name, $user_email = null)
    {
        return $this->teamsAddUserAsyncWithHttpInfo($org_name, $team_name, $user_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail $user_email The email of the user to add to the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddUserAsyncWithHttpInfo($org_name, $team_name, $user_email = null)
    {
        $returnType = 'object';
        $request = $this->teamsAddUserRequest($org_name, $team_name, $user_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddUser'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\UserEmail $user_email The email of the user to add to the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsAddUserRequest($org_name, $team_name, $user_email = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsAddUser'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsAddUser'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_email)) {
            $_tempBody = $user_email;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCreateTeam
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Team2 $team The information used to create the team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2008[]
     */
    public function teamsCreateTeam($org_name, $team = null)
    {
        list($response) = $this->teamsCreateTeamWithHttpInfo($org_name, $team);
        return $response;
    }

    /**
     * Operation teamsCreateTeamWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Team2 $team The information used to create the team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2008[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsCreateTeamWithHttpInfo($org_name, $team = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2008[]';
        $request = $this->teamsCreateTeamRequest($org_name, $team);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2008[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCreateTeamAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Team2 $team The information used to create the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateTeamAsync($org_name, $team = null)
    {
        return $this->teamsCreateTeamAsyncWithHttpInfo($org_name, $team)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCreateTeamAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Team2 $team The information used to create the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateTeamAsyncWithHttpInfo($org_name, $team = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2008[]';
        $request = $this->teamsCreateTeamRequest($org_name, $team);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCreateTeam'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  \Swagger\Client\Model\Team2 $team The information used to create the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsCreateTeamRequest($org_name, $team = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsCreateTeam'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($team)) {
            $_tempBody = $team;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDelete
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsDelete($org_name, $team_name)
    {
        $this->teamsDeleteWithHttpInfo($org_name, $team_name);
    }

    /**
     * Operation teamsDeleteWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsDeleteWithHttpInfo($org_name, $team_name)
    {
        $returnType = '';
        $request = $this->teamsDeleteRequest($org_name, $team_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteAsync($org_name, $team_name)
    {
        return $this->teamsDeleteAsyncWithHttpInfo($org_name, $team_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteAsyncWithHttpInfo($org_name, $team_name)
    {
        $returnType = '';
        $request = $this->teamsDeleteRequest($org_name, $team_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDelete'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsDeleteRequest($org_name, $team_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsDelete'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsDelete'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetTeam
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function teamsGetTeam($org_name, $team_name)
    {
        list($response) = $this->teamsGetTeamWithHttpInfo($org_name, $team_name);
        return $response;
    }

    /**
     * Operation teamsGetTeamWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsGetTeamWithHttpInfo($org_name, $team_name)
    {
        $returnType = 'object';
        $request = $this->teamsGetTeamRequest($org_name, $team_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetTeamAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetTeamAsync($org_name, $team_name)
    {
        return $this->teamsGetTeamAsyncWithHttpInfo($org_name, $team_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetTeamAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetTeamAsyncWithHttpInfo($org_name, $team_name)
    {
        $returnType = 'object';
        $request = $this->teamsGetTeamRequest($org_name, $team_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetTeam'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsGetTeamRequest($org_name, $team_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsGetTeam'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsGetTeam'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetUsers
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function teamsGetUsers($org_name, $team_name)
    {
        list($response) = $this->teamsGetUsersWithHttpInfo($org_name, $team_name);
        return $response;
    }

    /**
     * Operation teamsGetUsersWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsGetUsersWithHttpInfo($org_name, $team_name)
    {
        $returnType = 'object';
        $request = $this->teamsGetUsersRequest($org_name, $team_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetUsersAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetUsersAsync($org_name, $team_name)
    {
        return $this->teamsGetUsersAsyncWithHttpInfo($org_name, $team_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetUsersAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetUsersAsyncWithHttpInfo($org_name, $team_name)
    {
        $returnType = 'object';
        $request = $this->teamsGetUsersRequest($org_name, $team_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetUsers'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsGetUsersRequest($org_name, $team_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsGetUsers'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsGetUsers'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListAll
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2008[]
     */
    public function teamsListAll($org_name)
    {
        list($response) = $this->teamsListAllWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation teamsListAllWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2008[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListAllWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2008[]';
        $request = $this->teamsListAllRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2008[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListAllAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListAllAsync($org_name)
    {
        return $this->teamsListAllAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListAllAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListAllAsyncWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2008[]';
        $request = $this->teamsListAllRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListAll'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsListAllRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsListAll'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListApps
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function teamsListApps($org_name, $team_name)
    {
        list($response) = $this->teamsListAppsWithHttpInfo($org_name, $team_name);
        return $response;
    }

    /**
     * Operation teamsListAppsWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListAppsWithHttpInfo($org_name, $team_name)
    {
        $returnType = 'object[]';
        $request = $this->teamsListAppsRequest($org_name, $team_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListAppsAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListAppsAsync($org_name, $team_name)
    {
        return $this->teamsListAppsAsyncWithHttpInfo($org_name, $team_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListAppsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListAppsAsyncWithHttpInfo($org_name, $team_name)
    {
        $returnType = 'object[]';
        $request = $this->teamsListAppsRequest($org_name, $team_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListApps'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsListAppsRequest($org_name, $team_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsListApps'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsListApps'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveApp
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsRemoveApp($org_name, $team_name, $app_name)
    {
        $this->teamsRemoveAppWithHttpInfo($org_name, $team_name, $app_name);
    }

    /**
     * Operation teamsRemoveAppWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsRemoveAppWithHttpInfo($org_name, $team_name, $app_name)
    {
        $returnType = '';
        $request = $this->teamsRemoveAppRequest($org_name, $team_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveAppAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveAppAsync($org_name, $team_name, $app_name)
    {
        return $this->teamsRemoveAppAsyncWithHttpInfo($org_name, $team_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveAppAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveAppAsyncWithHttpInfo($org_name, $team_name, $app_name)
    {
        $returnType = '';
        $request = $this->teamsRemoveAppRequest($org_name, $team_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveApp'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsRemoveAppRequest($org_name, $team_name, $app_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsRemoveApp'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsRemoveApp'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling teamsRemoveApp'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveUser
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsRemoveUser($org_name, $team_name, $user_name)
    {
        $this->teamsRemoveUserWithHttpInfo($org_name, $team_name, $user_name);
    }

    /**
     * Operation teamsRemoveUserWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsRemoveUserWithHttpInfo($org_name, $team_name, $user_name)
    {
        $returnType = '';
        $request = $this->teamsRemoveUserRequest($org_name, $team_name, $user_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveUserAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveUserAsync($org_name, $team_name, $user_name)
    {
        return $this->teamsRemoveUserAsyncWithHttpInfo($org_name, $team_name, $user_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveUserAsyncWithHttpInfo($org_name, $team_name, $user_name)
    {
        $returnType = '';
        $request = $this->teamsRemoveUserRequest($org_name, $team_name, $user_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveUser'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsRemoveUserRequest($org_name, $team_name, $user_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsRemoveUser'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsRemoveUser'
            );
        }
        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling teamsRemoveUser'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/users/{user_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }
        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdate
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\Team1 $team The information used to update the team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function teamsUpdate($org_name, $team_name, $team = null)
    {
        list($response) = $this->teamsUpdateWithHttpInfo($org_name, $team_name, $team);
        return $response;
    }

    /**
     * Operation teamsUpdateWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\Team1 $team The information used to update the team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsUpdateWithHttpInfo($org_name, $team_name, $team = null)
    {
        $returnType = 'object';
        $request = $this->teamsUpdateRequest($org_name, $team_name, $team);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\Team1 $team The information used to update the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateAsync($org_name, $team_name, $team = null)
    {
        return $this->teamsUpdateAsyncWithHttpInfo($org_name, $team_name, $team)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\Team1 $team The information used to update the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateAsyncWithHttpInfo($org_name, $team_name, $team = null)
    {
        $returnType = 'object';
        $request = $this->teamsUpdateRequest($org_name, $team_name, $team);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdate'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  \Swagger\Client\Model\Team1 $team The information used to update the team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsUpdateRequest($org_name, $team_name, $team = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsUpdate'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsUpdate'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($team)) {
            $_tempBody = $team;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdatePermissions
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Team $team team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function teamsUpdatePermissions($org_name, $team_name, $app_name, $team = null)
    {
        list($response) = $this->teamsUpdatePermissionsWithHttpInfo($org_name, $team_name, $app_name, $team);
        return $response;
    }

    /**
     * Operation teamsUpdatePermissionsWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Team $team (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsUpdatePermissionsWithHttpInfo($org_name, $team_name, $app_name, $team = null)
    {
        $returnType = 'object';
        $request = $this->teamsUpdatePermissionsRequest($org_name, $team_name, $app_name, $team);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdatePermissionsAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Team $team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdatePermissionsAsync($org_name, $team_name, $app_name, $team = null)
    {
        return $this->teamsUpdatePermissionsAsyncWithHttpInfo($org_name, $team_name, $app_name, $team)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdatePermissionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Team $team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdatePermissionsAsyncWithHttpInfo($org_name, $team_name, $app_name, $team = null)
    {
        $returnType = 'object';
        $request = $this->teamsUpdatePermissionsRequest($org_name, $team_name, $app_name, $team);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdatePermissions'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $team_name The team&#39;s name (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Team $team (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function teamsUpdatePermissionsRequest($org_name, $team_name, $app_name, $team = null)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling teamsUpdatePermissions'
            );
        }
        // verify the required parameter 'team_name' is set
        if ($team_name === null || (is_array($team_name) && count($team_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_name when calling teamsUpdatePermissions'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling teamsUpdatePermissions'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($team_name !== null) {
            $resourcePath = str_replace(
                '{' . 'team_name' . '}',
                ObjectSerializer::toPathValue($team_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($team)) {
            $_tempBody = $team;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userApiTokensDelete
     *
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userApiTokensDelete($api_token_id)
    {
        $this->userApiTokensDeleteWithHttpInfo($api_token_id);
    }

    /**
     * Operation userApiTokensDeleteWithHttpInfo
     *
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userApiTokensDeleteWithHttpInfo($api_token_id)
    {
        $returnType = '';
        $request = $this->userApiTokensDeleteRequest($api_token_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation userApiTokensDeleteAsync
     *
     * 
     *
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userApiTokensDeleteAsync($api_token_id)
    {
        return $this->userApiTokensDeleteAsyncWithHttpInfo($api_token_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userApiTokensDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userApiTokensDeleteAsyncWithHttpInfo($api_token_id)
    {
        $returnType = '';
        $request = $this->userApiTokensDeleteRequest($api_token_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userApiTokensDelete'
     *
     * @param  string $api_token_id The unique ID (UUID) of the api token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userApiTokensDeleteRequest($api_token_id)
    {
        // verify the required parameter 'api_token_id' is set
        if ($api_token_id === null || (is_array($api_token_id) && count($api_token_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token_id when calling userApiTokensDelete'
            );
        }

        $resourcePath = '/v0.1/api_tokens/{api_token_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($api_token_id !== null) {
            $resourcePath = str_replace(
                '{' . 'api_token_id' . '}',
                ObjectSerializer::toPathValue($api_token_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userApiTokensList
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20078[]
     */
    public function userApiTokensList()
    {
        list($response) = $this->userApiTokensListWithHttpInfo();
        return $response;
    }

    /**
     * Operation userApiTokensListWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20078[], HTTP status code, HTTP response headers (array of strings)
     */
    public function userApiTokensListWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20078[]';
        $request = $this->userApiTokensListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20078[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation userApiTokensListAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userApiTokensListAsync()
    {
        return $this->userApiTokensListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userApiTokensListAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userApiTokensListAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20078[]';
        $request = $this->userApiTokensListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userApiTokensList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userApiTokensListRequest()
    {

        $resourcePath = '/v0.1/api_tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userApiTokensNew
     *
     * @param  \Swagger\Client\Model\Description1 $description Description of the token (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function userApiTokensNew($description = null)
    {
        list($response) = $this->userApiTokensNewWithHttpInfo($description);
        return $response;
    }

    /**
     * Operation userApiTokensNewWithHttpInfo
     *
     * @param  \Swagger\Client\Model\Description1 $description Description of the token (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function userApiTokensNewWithHttpInfo($description = null)
    {
        $returnType = 'object';
        $request = $this->userApiTokensNewRequest($description);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation userApiTokensNewAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\Description1 $description Description of the token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userApiTokensNewAsync($description = null)
    {
        return $this->userApiTokensNewAsyncWithHttpInfo($description)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userApiTokensNewAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\Description1 $description Description of the token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userApiTokensNewAsyncWithHttpInfo($description = null)
    {
        $returnType = 'object';
        $request = $this->userApiTokensNewRequest($description);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userApiTokensNew'
     *
     * @param  \Swagger\Client\Model\Description1 $description Description of the token (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userApiTokensNewRequest($description = null)
    {

        $resourcePath = '/v0.1/api_tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($description)) {
            $_tempBody = $description;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGet
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function usersGet()
    {
        list($response) = $this->usersGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation usersGetWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGetWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->usersGetRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGetAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetAsync()
    {
        return $this->usersGetAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGetAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->usersGetRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGet'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersGetRequest()
    {

        $resourcePath = '/v0.1/user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGetForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function usersGetForOrg($org_name, $user_name)
    {
        list($response) = $this->usersGetForOrgWithHttpInfo($org_name, $user_name);
        return $response;
    }

    /**
     * Operation usersGetForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGetForOrgWithHttpInfo($org_name, $user_name)
    {
        $returnType = 'object';
        $request = $this->usersGetForOrgRequest($org_name, $user_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGetForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetForOrgAsync($org_name, $user_name)
    {
        return $this->usersGetForOrgAsyncWithHttpInfo($org_name, $user_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGetForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetForOrgAsyncWithHttpInfo($org_name, $user_name)
    {
        $returnType = 'object';
        $request = $this->usersGetForOrgRequest($org_name, $user_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGetForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersGetForOrgRequest($org_name, $user_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling usersGetForOrg'
            );
        }
        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling usersGetForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/users/{user_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersGetUserMetadata
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function usersGetUserMetadata()
    {
        list($response) = $this->usersGetUserMetadataWithHttpInfo();
        return $response;
    }

    /**
     * Operation usersGetUserMetadataWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersGetUserMetadataWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->usersGetUserMetadataRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersGetUserMetadataAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetUserMetadataAsync()
    {
        return $this->usersGetUserMetadataAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersGetUserMetadataAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersGetUserMetadataAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->usersGetUserMetadataRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersGetUserMetadata'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersGetUserMetadataRequest()
    {

        $resourcePath = '/v0.1/user/metadata/optimizely';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20020[]
     */
    public function usersList($owner_name, $app_name)
    {
        list($response) = $this->usersListWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation usersListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20020[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersListWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20020[]';
        $request = $this->usersListRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20020[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersListAsync($owner_name, $app_name)
    {
        return $this->usersListAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersListAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20020[]';
        $request = $this->usersListRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersListRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling usersList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling usersList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersListForOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2006[]
     */
    public function usersListForOrg($org_name)
    {
        list($response) = $this->usersListForOrgWithHttpInfo($org_name);
        return $response;
    }

    /**
     * Operation usersListForOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2006[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersListForOrgWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2006[]';
        $request = $this->usersListForOrgRequest($org_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2006[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersListForOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersListForOrgAsync($org_name)
    {
        return $this->usersListForOrgAsyncWithHttpInfo($org_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersListForOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersListForOrgAsyncWithHttpInfo($org_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2006[]';
        $request = $this->usersListForOrgRequest($org_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersListForOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersListForOrgRequest($org_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling usersListForOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersRemoveFromOrg
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersRemoveFromOrg($org_name, $user_name)
    {
        $this->usersRemoveFromOrgWithHttpInfo($org_name, $user_name);
    }

    /**
     * Operation usersRemoveFromOrgWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersRemoveFromOrgWithHttpInfo($org_name, $user_name)
    {
        $returnType = '';
        $request = $this->usersRemoveFromOrgRequest($org_name, $user_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersRemoveFromOrgAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersRemoveFromOrgAsync($org_name, $user_name)
    {
        return $this->usersRemoveFromOrgAsyncWithHttpInfo($org_name, $user_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersRemoveFromOrgAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersRemoveFromOrgAsyncWithHttpInfo($org_name, $user_name)
    {
        $returnType = '';
        $request = $this->usersRemoveFromOrgRequest($org_name, $user_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersRemoveFromOrg'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersRemoveFromOrgRequest($org_name, $user_name)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling usersRemoveFromOrg'
            );
        }
        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling usersRemoveFromOrg'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/users/{user_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUpdate
     *
     * @param  \Swagger\Client\Model\User $user The data for the created user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function usersUpdate($user)
    {
        list($response) = $this->usersUpdateWithHttpInfo($user);
        return $response;
    }

    /**
     * Operation usersUpdateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\User $user The data for the created user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUpdateWithHttpInfo($user)
    {
        $returnType = 'object';
        $request = $this->usersUpdateRequest($user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUpdateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\User $user The data for the created user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUpdateAsync($user)
    {
        return $this->usersUpdateAsyncWithHttpInfo($user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\User $user The data for the created user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUpdateAsyncWithHttpInfo($user)
    {
        $returnType = 'object';
        $request = $this->usersUpdateRequest($user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUpdate'
     *
     * @param  \Swagger\Client\Model\User $user The data for the created user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersUpdateRequest($user)
    {
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling usersUpdate'
            );
        }

        $resourcePath = '/v0.1/user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($user)) {
            $_tempBody = $user;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersUpdateOrgRole
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     * @param  \Swagger\Client\Model\OrganizationUser $organization_user organization_user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function usersUpdateOrgRole($org_name, $user_name, $organization_user)
    {
        list($response) = $this->usersUpdateOrgRoleWithHttpInfo($org_name, $user_name, $organization_user);
        return $response;
    }

    /**
     * Operation usersUpdateOrgRoleWithHttpInfo
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     * @param  \Swagger\Client\Model\OrganizationUser $organization_user (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersUpdateOrgRoleWithHttpInfo($org_name, $user_name, $organization_user)
    {
        $returnType = 'object';
        $request = $this->usersUpdateOrgRoleRequest($org_name, $user_name, $organization_user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponseDefault2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersUpdateOrgRoleAsync
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     * @param  \Swagger\Client\Model\OrganizationUser $organization_user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUpdateOrgRoleAsync($org_name, $user_name, $organization_user)
    {
        return $this->usersUpdateOrgRoleAsyncWithHttpInfo($org_name, $user_name, $organization_user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersUpdateOrgRoleAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     * @param  \Swagger\Client\Model\OrganizationUser $organization_user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersUpdateOrgRoleAsyncWithHttpInfo($org_name, $user_name, $organization_user)
    {
        $returnType = 'object';
        $request = $this->usersUpdateOrgRoleRequest($org_name, $user_name, $organization_user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersUpdateOrgRole'
     *
     * @param  string $org_name The organization&#39;s name (required)
     * @param  string $user_name The slug name of the user (required)
     * @param  \Swagger\Client\Model\OrganizationUser $organization_user (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersUpdateOrgRoleRequest($org_name, $user_name, $organization_user)
    {
        // verify the required parameter 'org_name' is set
        if ($org_name === null || (is_array($org_name) && count($org_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_name when calling usersUpdateOrgRole'
            );
        }
        // verify the required parameter 'user_name' is set
        if ($user_name === null || (is_array($user_name) && count($user_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_name when calling usersUpdateOrgRole'
            );
        }
        // verify the required parameter 'organization_user' is set
        if ($organization_user === null || (is_array($organization_user) && count($organization_user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_user when calling usersUpdateOrgRole'
            );
        }

        $resourcePath = '/v0.1/orgs/{org_name}/users/{user_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($org_name !== null) {
            $resourcePath = str_replace(
                '{' . 'org_name' . '}',
                ObjectSerializer::toPathValue($org_name),
                $resourcePath
            );
        }
        // path params
        if ($user_name !== null) {
            $resourcePath = str_replace(
                '{' . 'user_name' . '}',
                ObjectSerializer::toPathValue($user_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($organization_user)) {
            $_tempBody = $organization_user;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
