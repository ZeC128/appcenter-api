<?php
/**
 * BuildApi
 * PHP version 5
 *
 * @category Class
 * @package  ZeC128\AppCenter
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * App Center Client
 *
 * Microsoft Visual Studio App Center API
 *
 * OpenAPI spec version: v0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ZeC128\AppCenter\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ZeC128\AppCenter\ApiException;
use ZeC128\AppCenter\Configuration;
use ZeC128\AppCenter\HeaderSelector;
use ZeC128\AppCenter\ObjectSerializer;

/**
 * BuildApi Class Doc Comment
 *
 * @category Class
 * @package  ZeC128\AppCenter
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BuildApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation branchConfigurationsCreate
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params1 $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20075
     */
    public function branchConfigurationsCreate($branch, $params, $owner_name, $app_name)
    {
        list($response) = $this->branchConfigurationsCreateWithHttpInfo($branch, $params, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation branchConfigurationsCreateWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params1 $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20075, HTTP status code, HTTP response headers (array of strings)
     */
    public function branchConfigurationsCreateWithHttpInfo($branch, $params, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075';
        $request = $this->branchConfigurationsCreateRequest($branch, $params, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation branchConfigurationsCreateAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params1 $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsCreateAsync($branch, $params, $owner_name, $app_name)
    {
        return $this->branchConfigurationsCreateAsyncWithHttpInfo($branch, $params, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation branchConfigurationsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params1 $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsCreateAsyncWithHttpInfo($branch, $params, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075';
        $request = $this->branchConfigurationsCreateRequest($branch, $params, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'branchConfigurationsCreate'
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params1 $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function branchConfigurationsCreateRequest($branch, $params, $owner_name, $app_name)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling branchConfigurationsCreate'
            );
        }
        // verify the required parameter 'params' is set
        if ($params === null || (is_array($params) && count($params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $params when calling branchConfigurationsCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling branchConfigurationsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling branchConfigurationsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($params)) {
            $_tempBody = $params;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation branchConfigurationsDelete
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload payload (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function branchConfigurationsDelete($branch, $owner_name, $app_name, $payload = null)
    {
        list($response) = $this->branchConfigurationsDeleteWithHttpInfo($branch, $owner_name, $app_name, $payload);
        return $response;
    }

    /**
     * Operation branchConfigurationsDeleteWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function branchConfigurationsDeleteWithHttpInfo($branch, $owner_name, $app_name, $payload = null)
    {
        $returnType = 'object';
        $request = $this->branchConfigurationsDeleteRequest($branch, $owner_name, $app_name, $payload);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation branchConfigurationsDeleteAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsDeleteAsync($branch, $owner_name, $app_name, $payload = null)
    {
        return $this->branchConfigurationsDeleteAsyncWithHttpInfo($branch, $owner_name, $app_name, $payload)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation branchConfigurationsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsDeleteAsyncWithHttpInfo($branch, $owner_name, $app_name, $payload = null)
    {
        $returnType = 'object';
        $request = $this->branchConfigurationsDeleteRequest($branch, $owner_name, $app_name, $payload);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'branchConfigurationsDelete'
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function branchConfigurationsDeleteRequest($branch, $owner_name, $app_name, $payload = null)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling branchConfigurationsDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling branchConfigurationsDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling branchConfigurationsDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($payload)) {
            $_tempBody = $payload;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation branchConfigurationsGet
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20075
     */
    public function branchConfigurationsGet($branch, $owner_name, $app_name)
    {
        list($response) = $this->branchConfigurationsGetWithHttpInfo($branch, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation branchConfigurationsGetWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20075, HTTP status code, HTTP response headers (array of strings)
     */
    public function branchConfigurationsGetWithHttpInfo($branch, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075';
        $request = $this->branchConfigurationsGetRequest($branch, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation branchConfigurationsGetAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsGetAsync($branch, $owner_name, $app_name)
    {
        return $this->branchConfigurationsGetAsyncWithHttpInfo($branch, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation branchConfigurationsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsGetAsyncWithHttpInfo($branch, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075';
        $request = $this->branchConfigurationsGetRequest($branch, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'branchConfigurationsGet'
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function branchConfigurationsGetRequest($branch, $owner_name, $app_name)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling branchConfigurationsGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling branchConfigurationsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling branchConfigurationsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation branchConfigurationsUpdate
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20075
     */
    public function branchConfigurationsUpdate($branch, $params, $owner_name, $app_name)
    {
        list($response) = $this->branchConfigurationsUpdateWithHttpInfo($branch, $params, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation branchConfigurationsUpdateWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20075, HTTP status code, HTTP response headers (array of strings)
     */
    public function branchConfigurationsUpdateWithHttpInfo($branch, $params, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075';
        $request = $this->branchConfigurationsUpdateRequest($branch, $params, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation branchConfigurationsUpdateAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsUpdateAsync($branch, $params, $owner_name, $app_name)
    {
        return $this->branchConfigurationsUpdateAsyncWithHttpInfo($branch, $params, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation branchConfigurationsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function branchConfigurationsUpdateAsyncWithHttpInfo($branch, $params, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20075';
        $request = $this->branchConfigurationsUpdateRequest($branch, $params, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'branchConfigurationsUpdate'
     *
     * @param  string $branch The branch name (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params $params Parameters of the configuration (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function branchConfigurationsUpdateRequest($branch, $params, $owner_name, $app_name)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling branchConfigurationsUpdate'
            );
        }
        // verify the required parameter 'params' is set
        if ($params === null || (is_array($params) && count($params) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $params when calling branchConfigurationsUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling branchConfigurationsUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling branchConfigurationsUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($params)) {
            $_tempBody = $params;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsCreate
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params2 $params Parameters of the build (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsCreate($branch, $owner_name, $app_name, $params = null)
    {
        list($response) = $this->buildsCreateWithHttpInfo($branch, $owner_name, $app_name, $params);
        return $response;
    }

    /**
     * Operation buildsCreateWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params2 $params Parameters of the build (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsCreateWithHttpInfo($branch, $owner_name, $app_name, $params = null)
    {
        $returnType = 'object';
        $request = $this->buildsCreateRequest($branch, $owner_name, $app_name, $params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsCreateAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params2 $params Parameters of the build (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsCreateAsync($branch, $owner_name, $app_name, $params = null)
    {
        return $this->buildsCreateAsyncWithHttpInfo($branch, $owner_name, $app_name, $params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params2 $params Parameters of the build (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsCreateAsyncWithHttpInfo($branch, $owner_name, $app_name, $params = null)
    {
        $returnType = 'object';
        $request = $this->buildsCreateRequest($branch, $owner_name, $app_name, $params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsCreate'
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Params2 $params Parameters of the build (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsCreateRequest($branch, $owner_name, $app_name, $params = null)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling buildsCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($params)) {
            $_tempBody = $params;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsDistribute
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\DistributeInfo $distribute_info The distribution details (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsDistribute($build_id, $distribute_info, $owner_name, $app_name)
    {
        list($response) = $this->buildsDistributeWithHttpInfo($build_id, $distribute_info, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsDistributeWithHttpInfo
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\DistributeInfo $distribute_info The distribution details (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsDistributeWithHttpInfo($build_id, $distribute_info, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsDistributeRequest($build_id, $distribute_info, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsDistributeAsync
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\DistributeInfo $distribute_info The distribution details (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsDistributeAsync($build_id, $distribute_info, $owner_name, $app_name)
    {
        return $this->buildsDistributeAsyncWithHttpInfo($build_id, $distribute_info, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsDistributeAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\DistributeInfo $distribute_info The distribution details (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsDistributeAsyncWithHttpInfo($build_id, $distribute_info, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsDistributeRequest($build_id, $distribute_info, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsDistribute'
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\DistributeInfo $distribute_info The distribution details (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsDistributeRequest($build_id, $distribute_info, $owner_name, $app_name)
    {
        // verify the required parameter 'build_id' is set
        if ($build_id === null || (is_array($build_id) && count($build_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_id when calling buildsDistribute'
            );
        }
        if ($build_id <= 0) {
            throw new \InvalidArgumentException('invalid value for "$build_id" when calling BuildApi.buildsDistribute, must be bigger than 0.');
        }

        // verify the required parameter 'distribute_info' is set
        if ($distribute_info === null || (is_array($distribute_info) && count($distribute_info) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribute_info when calling buildsDistribute'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsDistribute'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsDistribute'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/distribute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_id !== null) {
            $resourcePath = str_replace(
                '{' . 'build_id' . '}',
                ObjectSerializer::toPathValue($build_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($distribute_info)) {
            $_tempBody = $distribute_info;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsGet
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsGet($build_id, $owner_name, $app_name)
    {
        list($response) = $this->buildsGetWithHttpInfo($build_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsGetWithHttpInfo
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsGetWithHttpInfo($build_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetRequest($build_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsGetAsync
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetAsync($build_id, $owner_name, $app_name)
    {
        return $this->buildsGetAsyncWithHttpInfo($build_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetAsyncWithHttpInfo($build_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetRequest($build_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsGet'
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsGetRequest($build_id, $owner_name, $app_name)
    {
        // verify the required parameter 'build_id' is set
        if ($build_id === null || (is_array($build_id) && count($build_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_id when calling buildsGet'
            );
        }
        if ($build_id <= 0) {
            throw new \InvalidArgumentException('invalid value for "$build_id" when calling BuildApi.buildsGet, must be bigger than 0.');
        }

        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_id !== null) {
            $resourcePath = str_replace(
                '{' . 'build_id' . '}',
                ObjectSerializer::toPathValue($build_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsGetDownloadUri
     *
     * @param  int $build_id The build ID (required)
     * @param  string $download_type The download type (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsGetDownloadUri($build_id, $download_type, $owner_name, $app_name)
    {
        list($response) = $this->buildsGetDownloadUriWithHttpInfo($build_id, $download_type, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsGetDownloadUriWithHttpInfo
     *
     * @param  int $build_id The build ID (required)
     * @param  string $download_type The download type (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsGetDownloadUriWithHttpInfo($build_id, $download_type, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetDownloadUriRequest($build_id, $download_type, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsGetDownloadUriAsync
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  string $download_type The download type (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetDownloadUriAsync($build_id, $download_type, $owner_name, $app_name)
    {
        return $this->buildsGetDownloadUriAsyncWithHttpInfo($build_id, $download_type, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsGetDownloadUriAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  string $download_type The download type (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetDownloadUriAsyncWithHttpInfo($build_id, $download_type, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetDownloadUriRequest($build_id, $download_type, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsGetDownloadUri'
     *
     * @param  int $build_id The build ID (required)
     * @param  string $download_type The download type (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsGetDownloadUriRequest($build_id, $download_type, $owner_name, $app_name)
    {
        // verify the required parameter 'build_id' is set
        if ($build_id === null || (is_array($build_id) && count($build_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_id when calling buildsGetDownloadUri'
            );
        }
        if ($build_id <= 0) {
            throw new \InvalidArgumentException('invalid value for "$build_id" when calling BuildApi.buildsGetDownloadUri, must be bigger than 0.');
        }

        // verify the required parameter 'download_type' is set
        if ($download_type === null || (is_array($download_type) && count($download_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $download_type when calling buildsGetDownloadUri'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsGetDownloadUri'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsGetDownloadUri'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/downloads/{download_type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_id !== null) {
            $resourcePath = str_replace(
                '{' . 'build_id' . '}',
                ObjectSerializer::toPathValue($build_id),
                $resourcePath
            );
        }
        // path params
        if ($download_type !== null) {
            $resourcePath = str_replace(
                '{' . 'download_type' . '}',
                ObjectSerializer::toPathValue($download_type),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsGetLog
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsGetLog($build_id, $owner_name, $app_name)
    {
        list($response) = $this->buildsGetLogWithHttpInfo($build_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsGetLogWithHttpInfo
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsGetLogWithHttpInfo($build_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetLogRequest($build_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsGetLogAsync
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetLogAsync($build_id, $owner_name, $app_name)
    {
        return $this->buildsGetLogAsyncWithHttpInfo($build_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsGetLogAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetLogAsyncWithHttpInfo($build_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetLogRequest($build_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsGetLog'
     *
     * @param  int $build_id The build ID (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsGetLogRequest($build_id, $owner_name, $app_name)
    {
        // verify the required parameter 'build_id' is set
        if ($build_id === null || (is_array($build_id) && count($build_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_id when calling buildsGetLog'
            );
        }
        if ($build_id <= 0) {
            throw new \InvalidArgumentException('invalid value for "$build_id" when calling BuildApi.buildsGetLog, must be bigger than 0.');
        }

        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsGetLog'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsGetLog'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_id !== null) {
            $resourcePath = str_replace(
                '{' . 'build_id' . '}',
                ObjectSerializer::toPathValue($build_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsGetStatusByAppId
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsGetStatusByAppId($owner_name, $app_name)
    {
        list($response) = $this->buildsGetStatusByAppIdWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsGetStatusByAppIdWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsGetStatusByAppIdWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetStatusByAppIdRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsGetStatusByAppIdAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetStatusByAppIdAsync($owner_name, $app_name)
    {
        return $this->buildsGetStatusByAppIdAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsGetStatusByAppIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsGetStatusByAppIdAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsGetStatusByAppIdRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsGetStatusByAppId'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsGetStatusByAppIdRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsGetStatusByAppId'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsGetStatusByAppId'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/build_service_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsListBranches
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object][]
     */
    public function buildsListBranches($owner_name, $app_name)
    {
        list($response) = $this->buildsListBranchesWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsListBranchesWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object][], HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsListBranchesWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'map[string,object][]';
        $request = $this->buildsListBranchesRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object][]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsListBranchesAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListBranchesAsync($owner_name, $app_name)
    {
        return $this->buildsListBranchesAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsListBranchesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListBranchesAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'map[string,object][]';
        $request = $this->buildsListBranchesRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsListBranches'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsListBranchesRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsListBranches'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsListBranches'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsListByBranch
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20076[]
     */
    public function buildsListByBranch($branch, $owner_name, $app_name)
    {
        list($response) = $this->buildsListByBranchWithHttpInfo($branch, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsListByBranchWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20076[], HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsListByBranchWithHttpInfo($branch, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20076[]';
        $request = $this->buildsListByBranchRequest($branch, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20076[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsListByBranchAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListByBranchAsync($branch, $owner_name, $app_name)
    {
        return $this->buildsListByBranchAsyncWithHttpInfo($branch, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsListByBranchAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListByBranchAsyncWithHttpInfo($branch, $owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20076[]';
        $request = $this->buildsListByBranchRequest($branch, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsListByBranch'
     *
     * @param  string $branch The branch name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsListByBranchRequest($branch, $owner_name, $app_name)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling buildsListByBranch'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsListByBranch'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsListByBranch'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsListToolsetProjects
     *
     * @param  string $branch The branch name (required)
     * @param  string $os The desired OS for the project scan; normally the same as the app OS (required)
     * @param  string $platform The desired platform for the project scan (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  int $max_search_depth The depth of the repository to search for project files (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsListToolsetProjects($branch, $os, $platform, $owner_name, $app_name, $max_search_depth = null)
    {
        list($response) = $this->buildsListToolsetProjectsWithHttpInfo($branch, $os, $platform, $owner_name, $app_name, $max_search_depth);
        return $response;
    }

    /**
     * Operation buildsListToolsetProjectsWithHttpInfo
     *
     * @param  string $branch The branch name (required)
     * @param  string $os The desired OS for the project scan; normally the same as the app OS (required)
     * @param  string $platform The desired platform for the project scan (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  int $max_search_depth The depth of the repository to search for project files (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsListToolsetProjectsWithHttpInfo($branch, $os, $platform, $owner_name, $app_name, $max_search_depth = null)
    {
        $returnType = 'object';
        $request = $this->buildsListToolsetProjectsRequest($branch, $os, $platform, $owner_name, $app_name, $max_search_depth);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsListToolsetProjectsAsync
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $os The desired OS for the project scan; normally the same as the app OS (required)
     * @param  string $platform The desired platform for the project scan (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  int $max_search_depth The depth of the repository to search for project files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListToolsetProjectsAsync($branch, $os, $platform, $owner_name, $app_name, $max_search_depth = null)
    {
        return $this->buildsListToolsetProjectsAsyncWithHttpInfo($branch, $os, $platform, $owner_name, $app_name, $max_search_depth)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsListToolsetProjectsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $branch The branch name (required)
     * @param  string $os The desired OS for the project scan; normally the same as the app OS (required)
     * @param  string $platform The desired platform for the project scan (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  int $max_search_depth The depth of the repository to search for project files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListToolsetProjectsAsyncWithHttpInfo($branch, $os, $platform, $owner_name, $app_name, $max_search_depth = null)
    {
        $returnType = 'object';
        $request = $this->buildsListToolsetProjectsRequest($branch, $os, $platform, $owner_name, $app_name, $max_search_depth);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsListToolsetProjects'
     *
     * @param  string $branch The branch name (required)
     * @param  string $os The desired OS for the project scan; normally the same as the app OS (required)
     * @param  string $platform The desired platform for the project scan (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  int $max_search_depth The depth of the repository to search for project files (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsListToolsetProjectsRequest($branch, $os, $platform, $owner_name, $app_name, $max_search_depth = null)
    {
        // verify the required parameter 'branch' is set
        if ($branch === null || (is_array($branch) && count($branch) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $branch when calling buildsListToolsetProjects'
            );
        }
        // verify the required parameter 'os' is set
        if ($os === null || (is_array($os) && count($os) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $os when calling buildsListToolsetProjects'
            );
        }
        // verify the required parameter 'platform' is set
        if ($platform === null || (is_array($platform) && count($platform) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $platform when calling buildsListToolsetProjects'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsListToolsetProjects'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsListToolsetProjects'
            );
        }
        if ($max_search_depth !== null && $max_search_depth > 10) {
            throw new \InvalidArgumentException('invalid value for "$max_search_depth" when calling BuildApi.buildsListToolsetProjects, must be smaller than or equal to 10.');
        }
        if ($max_search_depth !== null && $max_search_depth < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_search_depth" when calling BuildApi.buildsListToolsetProjects, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/toolset_projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($os !== null) {
            $queryParams['os'] = ObjectSerializer::toQueryValue($os);
        }
        // query params
        if ($platform !== null) {
            $queryParams['platform'] = ObjectSerializer::toQueryValue($platform);
        }
        // query params
        if ($max_search_depth !== null) {
            $queryParams['maxSearchDepth'] = ObjectSerializer::toQueryValue($max_search_depth);
        }

        // path params
        if ($branch !== null) {
            $resourcePath = str_replace(
                '{' . 'branch' . '}',
                ObjectSerializer::toPathValue($branch),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsListToolsets
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $tools Toolset name (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20021
     */
    public function buildsListToolsets($owner_name, $app_name, $tools = null)
    {
        list($response) = $this->buildsListToolsetsWithHttpInfo($owner_name, $app_name, $tools);
        return $response;
    }

    /**
     * Operation buildsListToolsetsWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $tools Toolset name (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20021, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsListToolsetsWithHttpInfo($owner_name, $app_name, $tools = null)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20021';
        $request = $this->buildsListToolsetsRequest($owner_name, $app_name, $tools);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20021',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsListToolsetsAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $tools Toolset name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListToolsetsAsync($owner_name, $app_name, $tools = null)
    {
        return $this->buildsListToolsetsAsyncWithHttpInfo($owner_name, $app_name, $tools)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsListToolsetsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $tools Toolset name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListToolsetsAsyncWithHttpInfo($owner_name, $app_name, $tools = null)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20021';
        $request = $this->buildsListToolsetsRequest($owner_name, $app_name, $tools);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsListToolsets'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $tools Toolset name (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsListToolsetsRequest($owner_name, $app_name, $tools = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsListToolsets'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsListToolsets'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/toolsets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($tools !== null) {
            $queryParams['tools'] = ObjectSerializer::toQueryValue($tools);
        }

        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsListXamarinSDKBundles
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20018[]
     */
    public function buildsListXamarinSDKBundles($owner_name, $app_name)
    {
        list($response) = $this->buildsListXamarinSDKBundlesWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsListXamarinSDKBundlesWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20018[], HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsListXamarinSDKBundlesWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20018[]';
        $request = $this->buildsListXamarinSDKBundlesRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20018[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsListXamarinSDKBundlesAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListXamarinSDKBundlesAsync($owner_name, $app_name)
    {
        return $this->buildsListXamarinSDKBundlesAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsListXamarinSDKBundlesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListXamarinSDKBundlesAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20018[]';
        $request = $this->buildsListXamarinSDKBundlesRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsListXamarinSDKBundles'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsListXamarinSDKBundlesRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsListXamarinSDKBundles'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsListXamarinSDKBundles'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/xamarin_sdk_bundles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsListXcodeVersions
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20017[]
     */
    public function buildsListXcodeVersions($owner_name, $app_name)
    {
        list($response) = $this->buildsListXcodeVersionsWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsListXcodeVersionsWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20017[], HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsListXcodeVersionsWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20017[]';
        $request = $this->buildsListXcodeVersionsRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20017[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsListXcodeVersionsAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListXcodeVersionsAsync($owner_name, $app_name)
    {
        return $this->buildsListXcodeVersionsAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsListXcodeVersionsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsListXcodeVersionsAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20017[]';
        $request = $this->buildsListXcodeVersionsRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsListXcodeVersions'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsListXcodeVersionsRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsListXcodeVersions'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsListXcodeVersions'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/xcode_versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsUpdate
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Properties5 $properties properties (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function buildsUpdate($build_id, $properties, $owner_name, $app_name)
    {
        list($response) = $this->buildsUpdateWithHttpInfo($build_id, $properties, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation buildsUpdateWithHttpInfo
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Properties5 $properties (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsUpdateWithHttpInfo($build_id, $properties, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsUpdateRequest($build_id, $properties, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsUpdateAsync
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Properties5 $properties (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsUpdateAsync($build_id, $properties, $owner_name, $app_name)
    {
        return $this->buildsUpdateAsyncWithHttpInfo($build_id, $properties, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Properties5 $properties (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsUpdateAsyncWithHttpInfo($build_id, $properties, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->buildsUpdateRequest($build_id, $properties, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsUpdate'
     *
     * @param  int $build_id The build ID (required)
     * @param  \ZeC128\AppCenter\AppCenterApi\Properties5 $properties (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsUpdateRequest($build_id, $properties, $owner_name, $app_name)
    {
        // verify the required parameter 'build_id' is set
        if ($build_id === null || (is_array($build_id) && count($build_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_id when calling buildsUpdate'
            );
        }
        if ($build_id <= 0) {
            throw new \InvalidArgumentException('invalid value for "$build_id" when calling BuildApi.buildsUpdate, must be bigger than 0.');
        }

        // verify the required parameter 'properties' is set
        if ($properties === null || (is_array($properties) && count($properties) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $properties when calling buildsUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling buildsUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling buildsUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_id !== null) {
            $resourcePath = str_replace(
                '{' . 'build_id' . '}',
                ObjectSerializer::toPathValue($build_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($properties)) {
            $_tempBody = $properties;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildsWebhook
     *
     * @param  object $payload payload (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function buildsWebhook($payload = null)
    {
        $this->buildsWebhookWithHttpInfo($payload);
    }

    /**
     * Operation buildsWebhookWithHttpInfo
     *
     * @param  object $payload (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function buildsWebhookWithHttpInfo($payload = null)
    {
        $returnType = '';
        $request = $this->buildsWebhookRequest($payload);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation buildsWebhookAsync
     *
     * 
     *
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsWebhookAsync($payload = null)
    {
        return $this->buildsWebhookAsyncWithHttpInfo($payload)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildsWebhookAsyncWithHttpInfo
     *
     * 
     *
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildsWebhookAsyncWithHttpInfo($payload = null)
    {
        $returnType = '';
        $request = $this->buildsWebhookRequest($payload);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildsWebhook'
     *
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function buildsWebhookRequest($payload = null)
    {

        $resourcePath = '/v0.1/public/hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($payload)) {
            $_tempBody = $payload;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation commitsListByShaList
     *
     * @param  string[] $hashes A collection of commit SHAs comma-delimited (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function commitsListByShaList($hashes, $owner_name, $app_name)
    {
        list($response) = $this->commitsListByShaListWithHttpInfo($hashes, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation commitsListByShaListWithHttpInfo
     *
     * @param  string[] $hashes A collection of commit SHAs comma-delimited (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function commitsListByShaListWithHttpInfo($hashes, $owner_name, $app_name)
    {
        $returnType = 'object[]';
        $request = $this->commitsListByShaListRequest($hashes, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation commitsListByShaListAsync
     *
     * 
     *
     * @param  string[] $hashes A collection of commit SHAs comma-delimited (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commitsListByShaListAsync($hashes, $owner_name, $app_name)
    {
        return $this->commitsListByShaListAsyncWithHttpInfo($hashes, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation commitsListByShaListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string[] $hashes A collection of commit SHAs comma-delimited (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function commitsListByShaListAsyncWithHttpInfo($hashes, $owner_name, $app_name)
    {
        $returnType = 'object[]';
        $request = $this->commitsListByShaListRequest($hashes, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'commitsListByShaList'
     *
     * @param  string[] $hashes A collection of commit SHAs comma-delimited (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function commitsListByShaListRequest($hashes, $owner_name, $app_name)
    {
        // verify the required parameter 'hashes' is set
        if ($hashes === null || (is_array($hashes) && count($hashes) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hashes when calling commitsListByShaList'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling commitsListByShaList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling commitsListByShaList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/commits/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($hashes)) {
            $queryParams['hashes'] = $hashes;
        } else
        if ($hashes !== null) {
            $queryParams['hashes'] = ObjectSerializer::toQueryValue($hashes);
        }

        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fileAssetsCreate
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload payload (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function fileAssetsCreate($owner_name, $app_name, $payload = null)
    {
        list($response) = $this->fileAssetsCreateWithHttpInfo($owner_name, $app_name, $payload);
        return $response;
    }

    /**
     * Operation fileAssetsCreateWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function fileAssetsCreateWithHttpInfo($owner_name, $app_name, $payload = null)
    {
        $returnType = 'object';
        $request = $this->fileAssetsCreateRequest($owner_name, $app_name, $payload);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fileAssetsCreateAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileAssetsCreateAsync($owner_name, $app_name, $payload = null)
    {
        return $this->fileAssetsCreateAsyncWithHttpInfo($owner_name, $app_name, $payload)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fileAssetsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fileAssetsCreateAsyncWithHttpInfo($owner_name, $app_name, $payload = null)
    {
        $returnType = 'object';
        $request = $this->fileAssetsCreateRequest($owner_name, $app_name, $payload);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fileAssetsCreate'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $payload (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function fileAssetsCreateRequest($owner_name, $app_name, $payload = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling fileAssetsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling fileAssetsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/file_asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($payload)) {
            $_tempBody = $payload;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repositoriesList
     *
     * @param  string $source_host The source host (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $vsts_account_name Filter repositories only for specified account and project, \&quot;vstsProjectId\&quot; is required (optional)
     * @param  string $vsts_project_id Filter repositories only for specified account and project, \&quot;vstsAccountName\&quot; is required (optional)
     * @param  string $service_connection_id The id of the service connection (private). Required for GitLab self-hosted repositories (optional)
     * @param  string $form The selected form of the object (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20032[]
     */
    public function repositoriesList($source_host, $owner_name, $app_name, $vsts_account_name = null, $vsts_project_id = null, $service_connection_id = null, $form = null)
    {
        list($response) = $this->repositoriesListWithHttpInfo($source_host, $owner_name, $app_name, $vsts_account_name, $vsts_project_id, $service_connection_id, $form);
        return $response;
    }

    /**
     * Operation repositoriesListWithHttpInfo
     *
     * @param  string $source_host The source host (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $vsts_account_name Filter repositories only for specified account and project, \&quot;vstsProjectId\&quot; is required (optional)
     * @param  string $vsts_project_id Filter repositories only for specified account and project, \&quot;vstsAccountName\&quot; is required (optional)
     * @param  string $service_connection_id The id of the service connection (private). Required for GitLab self-hosted repositories (optional)
     * @param  string $form The selected form of the object (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20032[], HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoriesListWithHttpInfo($source_host, $owner_name, $app_name, $vsts_account_name = null, $vsts_project_id = null, $service_connection_id = null, $form = null)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20032[]';
        $request = $this->repositoriesListRequest($source_host, $owner_name, $app_name, $vsts_account_name, $vsts_project_id, $service_connection_id, $form);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20032[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation repositoriesListAsync
     *
     * 
     *
     * @param  string $source_host The source host (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $vsts_account_name Filter repositories only for specified account and project, \&quot;vstsProjectId\&quot; is required (optional)
     * @param  string $vsts_project_id Filter repositories only for specified account and project, \&quot;vstsAccountName\&quot; is required (optional)
     * @param  string $service_connection_id The id of the service connection (private). Required for GitLab self-hosted repositories (optional)
     * @param  string $form The selected form of the object (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoriesListAsync($source_host, $owner_name, $app_name, $vsts_account_name = null, $vsts_project_id = null, $service_connection_id = null, $form = null)
    {
        return $this->repositoriesListAsyncWithHttpInfo($source_host, $owner_name, $app_name, $vsts_account_name, $vsts_project_id, $service_connection_id, $form)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation repositoriesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $source_host The source host (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $vsts_account_name Filter repositories only for specified account and project, \&quot;vstsProjectId\&quot; is required (optional)
     * @param  string $vsts_project_id Filter repositories only for specified account and project, \&quot;vstsAccountName\&quot; is required (optional)
     * @param  string $service_connection_id The id of the service connection (private). Required for GitLab self-hosted repositories (optional)
     * @param  string $form The selected form of the object (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoriesListAsyncWithHttpInfo($source_host, $owner_name, $app_name, $vsts_account_name = null, $vsts_project_id = null, $service_connection_id = null, $form = null)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20032[]';
        $request = $this->repositoriesListRequest($source_host, $owner_name, $app_name, $vsts_account_name, $vsts_project_id, $service_connection_id, $form);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'repositoriesList'
     *
     * @param  string $source_host The source host (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $vsts_account_name Filter repositories only for specified account and project, \&quot;vstsProjectId\&quot; is required (optional)
     * @param  string $vsts_project_id Filter repositories only for specified account and project, \&quot;vstsAccountName\&quot; is required (optional)
     * @param  string $service_connection_id The id of the service connection (private). Required for GitLab self-hosted repositories (optional)
     * @param  string $form The selected form of the object (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function repositoriesListRequest($source_host, $owner_name, $app_name, $vsts_account_name = null, $vsts_project_id = null, $service_connection_id = null, $form = null)
    {
        // verify the required parameter 'source_host' is set
        if ($source_host === null || (is_array($source_host) && count($source_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_host when calling repositoriesList'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling repositoriesList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling repositoriesList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/source_hosts/{source_host}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($vsts_account_name !== null) {
            $queryParams['vstsAccountName'] = ObjectSerializer::toQueryValue($vsts_account_name);
        }
        // query params
        if ($vsts_project_id !== null) {
            $queryParams['vstsProjectId'] = ObjectSerializer::toQueryValue($vsts_project_id);
        }
        // query params
        if ($service_connection_id !== null) {
            $queryParams['service_connection_id'] = ObjectSerializer::toQueryValue($service_connection_id);
        }
        // query params
        if ($form !== null) {
            $queryParams['form'] = ObjectSerializer::toQueryValue($form);
        }

        // path params
        if ($source_host !== null) {
            $resourcePath = str_replace(
                '{' . 'source_host' . '}',
                ObjectSerializer::toPathValue($source_host),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repositoryConfigurationsCreateOrUpdate
     *
     * @param  object $repo The repository information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function repositoryConfigurationsCreateOrUpdate($repo, $owner_name, $app_name)
    {
        list($response) = $this->repositoryConfigurationsCreateOrUpdateWithHttpInfo($repo, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation repositoryConfigurationsCreateOrUpdateWithHttpInfo
     *
     * @param  object $repo The repository information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryConfigurationsCreateOrUpdateWithHttpInfo($repo, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->repositoryConfigurationsCreateOrUpdateRequest($repo, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation repositoryConfigurationsCreateOrUpdateAsync
     *
     * 
     *
     * @param  object $repo The repository information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoryConfigurationsCreateOrUpdateAsync($repo, $owner_name, $app_name)
    {
        return $this->repositoryConfigurationsCreateOrUpdateAsyncWithHttpInfo($repo, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation repositoryConfigurationsCreateOrUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  object $repo The repository information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoryConfigurationsCreateOrUpdateAsyncWithHttpInfo($repo, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->repositoryConfigurationsCreateOrUpdateRequest($repo, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'repositoryConfigurationsCreateOrUpdate'
     *
     * @param  object $repo The repository information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function repositoryConfigurationsCreateOrUpdateRequest($repo, $owner_name, $app_name)
    {
        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling repositoryConfigurationsCreateOrUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling repositoryConfigurationsCreateOrUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling repositoryConfigurationsCreateOrUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/repo_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($repo)) {
            $_tempBody = $repo;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repositoryConfigurationsDelete
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function repositoryConfigurationsDelete($owner_name, $app_name)
    {
        list($response) = $this->repositoryConfigurationsDeleteWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation repositoryConfigurationsDeleteWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryConfigurationsDeleteWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->repositoryConfigurationsDeleteRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation repositoryConfigurationsDeleteAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoryConfigurationsDeleteAsync($owner_name, $app_name)
    {
        return $this->repositoryConfigurationsDeleteAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation repositoryConfigurationsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoryConfigurationsDeleteAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->repositoryConfigurationsDeleteRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'repositoryConfigurationsDelete'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function repositoryConfigurationsDeleteRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling repositoryConfigurationsDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling repositoryConfigurationsDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/repo_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repositoryConfigurationsList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_inactive Include inactive configurations if none are active (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ZeC128\AppCenter\AppCenterApi\InlineResponse20033[]
     */
    public function repositoryConfigurationsList($owner_name, $app_name, $include_inactive = null)
    {
        list($response) = $this->repositoryConfigurationsListWithHttpInfo($owner_name, $app_name, $include_inactive);
        return $response;
    }

    /**
     * Operation repositoryConfigurationsListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_inactive Include inactive configurations if none are active (optional)
     *
     * @throws \ZeC128\AppCenter\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ZeC128\AppCenter\AppCenterApi\InlineResponse20033[], HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryConfigurationsListWithHttpInfo($owner_name, $app_name, $include_inactive = null)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20033[]';
        $request = $this->repositoryConfigurationsListRequest($owner_name, $app_name, $include_inactive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ZeC128\AppCenter\AppCenterApi\InlineResponse20033[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation repositoryConfigurationsListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_inactive Include inactive configurations if none are active (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoryConfigurationsListAsync($owner_name, $app_name, $include_inactive = null)
    {
        return $this->repositoryConfigurationsListAsyncWithHttpInfo($owner_name, $app_name, $include_inactive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation repositoryConfigurationsListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_inactive Include inactive configurations if none are active (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function repositoryConfigurationsListAsyncWithHttpInfo($owner_name, $app_name, $include_inactive = null)
    {
        $returnType = '\ZeC128\AppCenter\AppCenterApi\InlineResponse20033[]';
        $request = $this->repositoryConfigurationsListRequest($owner_name, $app_name, $include_inactive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'repositoryConfigurationsList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_inactive Include inactive configurations if none are active (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function repositoryConfigurationsListRequest($owner_name, $app_name, $include_inactive = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling repositoryConfigurationsList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling repositoryConfigurationsList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/repo_config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_inactive !== null) {
            $queryParams['includeInactive'] = ObjectSerializer::toQueryValue($include_inactive);
        }

        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
