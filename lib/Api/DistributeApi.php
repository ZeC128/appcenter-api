<?php
/**
 * DistributeApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * App Center Client
 *
 * Microsoft Visual Studio App Center API
 *
 * OpenAPI spec version: v0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * DistributeApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DistributeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation appleMappingCreate
     *
     * @param  \Swagger\Client\Model\Body14 $body The apple app mapping object (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appleMappingCreate($body, $owner_name, $app_name)
    {
        list($response) = $this->appleMappingCreateWithHttpInfo($body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appleMappingCreateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\Body14 $body The apple app mapping object (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appleMappingCreateWithHttpInfo($body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appleMappingCreateRequest($body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appleMappingCreateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\Body14 $body The apple app mapping object (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingCreateAsync($body, $owner_name, $app_name)
    {
        return $this->appleMappingCreateAsyncWithHttpInfo($body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appleMappingCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\Body14 $body The apple app mapping object (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingCreateAsyncWithHttpInfo($body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appleMappingCreateRequest($body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appleMappingCreate'
     *
     * @param  \Swagger\Client\Model\Body14 $body The apple app mapping object (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appleMappingCreateRequest($body, $owner_name, $app_name)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling appleMappingCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appleMappingCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appleMappingCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/apple_mapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appleMappingDelete
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appleMappingDelete($owner_name, $app_name, $body = null)
    {
        $this->appleMappingDeleteWithHttpInfo($owner_name, $app_name, $body);
    }

    /**
     * Operation appleMappingDeleteWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appleMappingDeleteWithHttpInfo($owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->appleMappingDeleteRequest($owner_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appleMappingDeleteAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingDeleteAsync($owner_name, $app_name, $body = null)
    {
        return $this->appleMappingDeleteAsyncWithHttpInfo($owner_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appleMappingDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingDeleteAsyncWithHttpInfo($owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->appleMappingDeleteRequest($owner_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appleMappingDelete'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appleMappingDeleteRequest($owner_name, $app_name, $body = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appleMappingDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appleMappingDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/apple_mapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appleMappingGet
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function appleMappingGet($owner_name, $app_name)
    {
        list($response) = $this->appleMappingGetWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appleMappingGetWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function appleMappingGetWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appleMappingGetRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appleMappingGetAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingGetAsync($owner_name, $app_name)
    {
        return $this->appleMappingGetAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appleMappingGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingGetAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->appleMappingGetRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appleMappingGet'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appleMappingGetRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appleMappingGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appleMappingGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/apple_mapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appleMappingTestFlightGroups
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20077[]
     */
    public function appleMappingTestFlightGroups($owner_name, $app_name)
    {
        list($response) = $this->appleMappingTestFlightGroupsWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation appleMappingTestFlightGroupsWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20077[], HTTP status code, HTTP response headers (array of strings)
     */
    public function appleMappingTestFlightGroupsWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20077[]';
        $request = $this->appleMappingTestFlightGroupsRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20077[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation appleMappingTestFlightGroupsAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingTestFlightGroupsAsync($owner_name, $app_name)
    {
        return $this->appleMappingTestFlightGroupsAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appleMappingTestFlightGroupsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appleMappingTestFlightGroupsAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20077[]';
        $request = $this->appleMappingTestFlightGroupsRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appleMappingTestFlightGroups'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appleMappingTestFlightGroupsRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling appleMappingTestFlightGroups'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling appleMappingTestFlightGroups'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/apple_test_flight_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesDeviceDetails
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function devicesDeviceDetails($device_udid)
    {
        list($response) = $this->devicesDeviceDetailsWithHttpInfo($device_udid);
        return $response;
    }

    /**
     * Operation devicesDeviceDetailsWithHttpInfo
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesDeviceDetailsWithHttpInfo($device_udid)
    {
        $returnType = 'object';
        $request = $this->devicesDeviceDetailsRequest($device_udid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesDeviceDetailsAsync
     *
     * 
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceDetailsAsync($device_udid)
    {
        return $this->devicesDeviceDetailsAsyncWithHttpInfo($device_udid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesDeviceDetailsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesDeviceDetailsAsyncWithHttpInfo($device_udid)
    {
        $returnType = 'object';
        $request = $this->devicesDeviceDetailsRequest($device_udid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesDeviceDetails'
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesDeviceDetailsRequest($device_udid)
    {
        // verify the required parameter 'device_udid' is set
        if ($device_udid === null || (is_array($device_udid) && count($device_udid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_udid when calling devicesDeviceDetails'
            );
        }

        $resourcePath = '/v0.1/user/devices/{device_udid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($device_udid !== null) {
            $resourcePath = str_replace(
                '{' . 'device_udid' . '}',
                ObjectSerializer::toPathValue($device_udid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesGetReleaseUpdateDevicesStatus
     *
     * @param  string $release_id The ID of the release. (required)
     * @param  string $resign_id The ID of the resign operation. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_provisioning_profile A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is &#39;complete&#39; or &#39;preparing_for_testers&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function devicesGetReleaseUpdateDevicesStatus($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile = null)
    {
        list($response) = $this->devicesGetReleaseUpdateDevicesStatusWithHttpInfo($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile);
        return $response;
    }

    /**
     * Operation devicesGetReleaseUpdateDevicesStatusWithHttpInfo
     *
     * @param  string $release_id The ID of the release. (required)
     * @param  string $resign_id The ID of the resign operation. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_provisioning_profile A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is &#39;complete&#39; or &#39;preparing_for_testers&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesGetReleaseUpdateDevicesStatusWithHttpInfo($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile = null)
    {
        $returnType = 'object';
        $request = $this->devicesGetReleaseUpdateDevicesStatusRequest($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesGetReleaseUpdateDevicesStatusAsync
     *
     * 
     *
     * @param  string $release_id The ID of the release. (required)
     * @param  string $resign_id The ID of the resign operation. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_provisioning_profile A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is &#39;complete&#39; or &#39;preparing_for_testers&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesGetReleaseUpdateDevicesStatusAsync($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile = null)
    {
        return $this->devicesGetReleaseUpdateDevicesStatusAsyncWithHttpInfo($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesGetReleaseUpdateDevicesStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $release_id The ID of the release. (required)
     * @param  string $resign_id The ID of the resign operation. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_provisioning_profile A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is &#39;complete&#39; or &#39;preparing_for_testers&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesGetReleaseUpdateDevicesStatusAsyncWithHttpInfo($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile = null)
    {
        $returnType = 'object';
        $request = $this->devicesGetReleaseUpdateDevicesStatusRequest($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesGetReleaseUpdateDevicesStatus'
     *
     * @param  string $release_id The ID of the release. (required)
     * @param  string $resign_id The ID of the resign operation. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $include_provisioning_profile A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is &#39;complete&#39; or &#39;preparing_for_testers&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesGetReleaseUpdateDevicesStatusRequest($release_id, $resign_id, $owner_name, $app_name, $include_provisioning_profile = null)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling devicesGetReleaseUpdateDevicesStatus'
            );
        }
        // verify the required parameter 'resign_id' is set
        if ($resign_id === null || (is_array($resign_id) && count($resign_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resign_id when calling devicesGetReleaseUpdateDevicesStatus'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling devicesGetReleaseUpdateDevicesStatus'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling devicesGetReleaseUpdateDevicesStatus'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices/{resign_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_provisioning_profile !== null) {
            $queryParams['include_provisioning_profile'] = ObjectSerializer::toQueryValue($include_provisioning_profile);
        }

        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($resign_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resign_id' . '}',
                ObjectSerializer::toPathValue($resign_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesList
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  float $release_id when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2003[]
     */
    public function devicesList($distribution_group_name, $owner_name, $app_name, $release_id = null)
    {
        list($response) = $this->devicesListWithHttpInfo($distribution_group_name, $owner_name, $app_name, $release_id);
        return $response;
    }

    /**
     * Operation devicesListWithHttpInfo
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  float $release_id when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2003[], HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesListWithHttpInfo($distribution_group_name, $owner_name, $app_name, $release_id = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003[]';
        $request = $this->devicesListRequest($distribution_group_name, $owner_name, $app_name, $release_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2003[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesListAsync
     *
     * 
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  float $release_id when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesListAsync($distribution_group_name, $owner_name, $app_name, $release_id = null)
    {
        return $this->devicesListAsyncWithHttpInfo($distribution_group_name, $owner_name, $app_name, $release_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  float $release_id when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesListAsyncWithHttpInfo($distribution_group_name, $owner_name, $app_name, $release_id = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003[]';
        $request = $this->devicesListRequest($distribution_group_name, $owner_name, $app_name, $release_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesList'
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  float $release_id when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesListRequest($distribution_group_name, $owner_name, $app_name, $release_id = null)
    {
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling devicesList'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling devicesList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling devicesList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($release_id !== null) {
            $queryParams['release_id'] = ObjectSerializer::toQueryValue($release_id);
        }

        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesListCsvFormat
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $unprovisioned_only when true, filters out provisioned devices (optional, default to false)
     * @param  string[] $udids multiple UDIDs which should be part of the resulting CSV. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function devicesListCsvFormat($distribution_group_name, $owner_name, $app_name, $unprovisioned_only = 'false', $udids = null)
    {
        $this->devicesListCsvFormatWithHttpInfo($distribution_group_name, $owner_name, $app_name, $unprovisioned_only, $udids);
    }

    /**
     * Operation devicesListCsvFormatWithHttpInfo
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $unprovisioned_only when true, filters out provisioned devices (optional, default to false)
     * @param  string[] $udids multiple UDIDs which should be part of the resulting CSV. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesListCsvFormatWithHttpInfo($distribution_group_name, $owner_name, $app_name, $unprovisioned_only = 'false', $udids = null)
    {
        $returnType = '';
        $request = $this->devicesListCsvFormatRequest($distribution_group_name, $owner_name, $app_name, $unprovisioned_only, $udids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesListCsvFormatAsync
     *
     * 
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $unprovisioned_only when true, filters out provisioned devices (optional, default to false)
     * @param  string[] $udids multiple UDIDs which should be part of the resulting CSV. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesListCsvFormatAsync($distribution_group_name, $owner_name, $app_name, $unprovisioned_only = 'false', $udids = null)
    {
        return $this->devicesListCsvFormatAsyncWithHttpInfo($distribution_group_name, $owner_name, $app_name, $unprovisioned_only, $udids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesListCsvFormatAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $unprovisioned_only when true, filters out provisioned devices (optional, default to false)
     * @param  string[] $udids multiple UDIDs which should be part of the resulting CSV. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesListCsvFormatAsyncWithHttpInfo($distribution_group_name, $owner_name, $app_name, $unprovisioned_only = 'false', $udids = null)
    {
        $returnType = '';
        $request = $this->devicesListCsvFormatRequest($distribution_group_name, $owner_name, $app_name, $unprovisioned_only, $udids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesListCsvFormat'
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $unprovisioned_only when true, filters out provisioned devices (optional, default to false)
     * @param  string[] $udids multiple UDIDs which should be part of the resulting CSV. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesListCsvFormatRequest($distribution_group_name, $owner_name, $app_name, $unprovisioned_only = 'false', $udids = null)
    {
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling devicesListCsvFormat'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling devicesListCsvFormat'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling devicesListCsvFormat'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices/download_devices_list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($unprovisioned_only !== null) {
            $queryParams['unprovisioned_only'] = ObjectSerializer::toQueryValue($unprovisioned_only);
        }
        // query params
        if (is_array($udids)) {
            $queryParams['udids'] = $udids;
        } else
        if ($udids !== null) {
            $queryParams['udids'] = ObjectSerializer::toQueryValue($udids);
        }

        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/csv'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesRegisterUserForDevice
     *
     * @param  string $user_id The ID of the user (required)
     * @param  \Swagger\Client\Model\Body $body The device info. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function devicesRegisterUserForDevice($user_id, $body)
    {
        list($response) = $this->devicesRegisterUserForDeviceWithHttpInfo($user_id, $body);
        return $response;
    }

    /**
     * Operation devicesRegisterUserForDeviceWithHttpInfo
     *
     * @param  string $user_id The ID of the user (required)
     * @param  \Swagger\Client\Model\Body $body The device info. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesRegisterUserForDeviceWithHttpInfo($user_id, $body)
    {
        $returnType = 'object';
        $request = $this->devicesRegisterUserForDeviceRequest($user_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesRegisterUserForDeviceAsync
     *
     * 
     *
     * @param  string $user_id The ID of the user (required)
     * @param  \Swagger\Client\Model\Body $body The device info. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesRegisterUserForDeviceAsync($user_id, $body)
    {
        return $this->devicesRegisterUserForDeviceAsyncWithHttpInfo($user_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesRegisterUserForDeviceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $user_id The ID of the user (required)
     * @param  \Swagger\Client\Model\Body $body The device info. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesRegisterUserForDeviceAsyncWithHttpInfo($user_id, $body)
    {
        $returnType = 'object';
        $request = $this->devicesRegisterUserForDeviceRequest($user_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesRegisterUserForDevice'
     *
     * @param  string $user_id The ID of the user (required)
     * @param  \Swagger\Client\Model\Body $body The device info. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesRegisterUserForDeviceRequest($user_id, $body)
    {
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_id when calling devicesRegisterUserForDevice'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling devicesRegisterUserForDevice'
            );
        }

        $resourcePath = '/v0.1/users/{user_id}/devices/register';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesRemoveUserDevice
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function devicesRemoveUserDevice($device_udid)
    {
        $this->devicesRemoveUserDeviceWithHttpInfo($device_udid);
    }

    /**
     * Operation devicesRemoveUserDeviceWithHttpInfo
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesRemoveUserDeviceWithHttpInfo($device_udid)
    {
        $returnType = '';
        $request = $this->devicesRemoveUserDeviceRequest($device_udid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesRemoveUserDeviceAsync
     *
     * 
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesRemoveUserDeviceAsync($device_udid)
    {
        return $this->devicesRemoveUserDeviceAsyncWithHttpInfo($device_udid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesRemoveUserDeviceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesRemoveUserDeviceAsyncWithHttpInfo($device_udid)
    {
        $returnType = '';
        $request = $this->devicesRemoveUserDeviceRequest($device_udid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesRemoveUserDevice'
     *
     * @param  string $device_udid The UDID of the device (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesRemoveUserDeviceRequest($device_udid)
    {
        // verify the required parameter 'device_udid' is set
        if ($device_udid === null || (is_array($device_udid) && count($device_udid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_udid when calling devicesRemoveUserDevice'
            );
        }

        $resourcePath = '/v0.1/user/devices/{device_udid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($device_udid !== null) {
            $resourcePath = str_replace(
                '{' . 'device_udid' . '}',
                ObjectSerializer::toPathValue($device_udid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation devicesUserDevicesList
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2003[]
     */
    public function devicesUserDevicesList()
    {
        list($response) = $this->devicesUserDevicesListWithHttpInfo();
        return $response;
    }

    /**
     * Operation devicesUserDevicesListWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2003[], HTTP status code, HTTP response headers (array of strings)
     */
    public function devicesUserDevicesListWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003[]';
        $request = $this->devicesUserDevicesListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2003[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation devicesUserDevicesListAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesUserDevicesListAsync()
    {
        return $this->devicesUserDevicesListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation devicesUserDevicesListAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function devicesUserDevicesListAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003[]';
        $request = $this->devicesUserDevicesListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'devicesUserDevicesList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function devicesUserDevicesListRequest()
    {

        $resourcePath = '/v0.1/user/devices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation distibutionReleasesInstallAnalytics
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  \Swagger\Client\Model\Body1 $body The install analytics request payload (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function distibutionReleasesInstallAnalytics($owner_name, $app_name, $body)
    {
        $this->distibutionReleasesInstallAnalyticsWithHttpInfo($owner_name, $app_name, $body);
    }

    /**
     * Operation distibutionReleasesInstallAnalyticsWithHttpInfo
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  \Swagger\Client\Model\Body1 $body The install analytics request payload (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function distibutionReleasesInstallAnalyticsWithHttpInfo($owner_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->distibutionReleasesInstallAnalyticsRequest($owner_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation distibutionReleasesInstallAnalyticsAsync
     *
     * 
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  \Swagger\Client\Model\Body1 $body The install analytics request payload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distibutionReleasesInstallAnalyticsAsync($owner_name, $app_name, $body)
    {
        return $this->distibutionReleasesInstallAnalyticsAsyncWithHttpInfo($owner_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation distibutionReleasesInstallAnalyticsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  \Swagger\Client\Model\Body1 $body The install analytics request payload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function distibutionReleasesInstallAnalyticsAsyncWithHttpInfo($owner_name, $app_name, $body)
    {
        $returnType = '';
        $request = $this->distibutionReleasesInstallAnalyticsRequest($owner_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'distibutionReleasesInstallAnalytics'
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  \Swagger\Client\Model\Body1 $body The install analytics request payload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function distibutionReleasesInstallAnalyticsRequest($owner_name, $app_name, $body)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling distibutionReleasesInstallAnalytics'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling distibutionReleasesInstallAnalytics'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling distibutionReleasesInstallAnalytics'
            );
        }

        $resourcePath = '/v0.1/public/apps/{owner_name}/{app_name}/install_analytics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation provisioningProfile
     *
     * @param  int $release_id The release_id (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProvisioningProfileResponse
     */
    public function provisioningProfile($release_id, $owner_name, $app_name)
    {
        list($response) = $this->provisioningProfileWithHttpInfo($release_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation provisioningProfileWithHttpInfo
     *
     * @param  int $release_id The release_id (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProvisioningProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function provisioningProfileWithHttpInfo($release_id, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ProvisioningProfileResponse';
        $request = $this->provisioningProfileRequest($release_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProvisioningProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation provisioningProfileAsync
     *
     * 
     *
     * @param  int $release_id The release_id (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisioningProfileAsync($release_id, $owner_name, $app_name)
    {
        return $this->provisioningProfileAsyncWithHttpInfo($release_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation provisioningProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The release_id (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function provisioningProfileAsyncWithHttpInfo($release_id, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\ProvisioningProfileResponse';
        $request = $this->provisioningProfileRequest($release_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'provisioningProfile'
     *
     * @param  int $release_id The release_id (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function provisioningProfileRequest($release_id, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling provisioningProfile'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling provisioningProfile'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling provisioningProfile'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/provisioning_profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releaseUploadsComplete
     *
     * @param  string $upload_id The ID of the upload (required)
     * @param  \Swagger\Client\Model\Body10 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releaseUploadsComplete($upload_id, $body, $owner_name, $app_name)
    {
        list($response) = $this->releaseUploadsCompleteWithHttpInfo($upload_id, $body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releaseUploadsCompleteWithHttpInfo
     *
     * @param  string $upload_id The ID of the upload (required)
     * @param  \Swagger\Client\Model\Body10 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releaseUploadsCompleteWithHttpInfo($upload_id, $body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releaseUploadsCompleteRequest($upload_id, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releaseUploadsCompleteAsync
     *
     * 
     *
     * @param  string $upload_id The ID of the upload (required)
     * @param  \Swagger\Client\Model\Body10 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releaseUploadsCompleteAsync($upload_id, $body, $owner_name, $app_name)
    {
        return $this->releaseUploadsCompleteAsyncWithHttpInfo($upload_id, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releaseUploadsCompleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $upload_id The ID of the upload (required)
     * @param  \Swagger\Client\Model\Body10 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releaseUploadsCompleteAsyncWithHttpInfo($upload_id, $body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releaseUploadsCompleteRequest($upload_id, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releaseUploadsComplete'
     *
     * @param  string $upload_id The ID of the upload (required)
     * @param  \Swagger\Client\Model\Body10 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releaseUploadsCompleteRequest($upload_id, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'upload_id' is set
        if ($upload_id === null || (is_array($upload_id) && count($upload_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload_id when calling releaseUploadsComplete'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releaseUploadsComplete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releaseUploadsComplete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releaseUploadsComplete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/release_uploads/{upload_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($upload_id !== null) {
            $resourcePath = str_replace(
                '{' . 'upload_id' . '}',
                ObjectSerializer::toPathValue($upload_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releaseUploadsCreate
     *
     * @param  \Swagger\Client\Model\Body11 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releaseUploadsCreate($body, $owner_name, $app_name)
    {
        list($response) = $this->releaseUploadsCreateWithHttpInfo($body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releaseUploadsCreateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\Body11 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releaseUploadsCreateWithHttpInfo($body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releaseUploadsCreateRequest($body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releaseUploadsCreateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\Body11 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releaseUploadsCreateAsync($body, $owner_name, $app_name)
    {
        return $this->releaseUploadsCreateAsyncWithHttpInfo($body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releaseUploadsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\Body11 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releaseUploadsCreateAsyncWithHttpInfo($body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releaseUploadsCreateRequest($body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releaseUploadsCreate'
     *
     * @param  \Swagger\Client\Model\Body11 $body The release information (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releaseUploadsCreateRequest($body, $owner_name, $app_name)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releaseUploadsCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releaseUploadsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releaseUploadsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/release_uploads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesAddDistributionGroup
     *
     * @param  int $release_id The ID of the release (required)
     * @param  object $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2011
     */
    public function releasesAddDistributionGroup($release_id, $body, $owner_name, $app_name)
    {
        list($response) = $this->releasesAddDistributionGroupWithHttpInfo($release_id, $body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesAddDistributionGroupWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  object $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2011, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesAddDistributionGroupWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2011';
        $request = $this->releasesAddDistributionGroupRequest($release_id, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesAddDistributionGroupAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  object $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAddDistributionGroupAsync($release_id, $body, $owner_name, $app_name)
    {
        return $this->releasesAddDistributionGroupAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesAddDistributionGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  object $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAddDistributionGroupAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2011';
        $request = $this->releasesAddDistributionGroupRequest($release_id, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesAddDistributionGroup'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  object $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesAddDistributionGroupRequest($release_id, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesAddDistributionGroup'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesAddDistributionGroup'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesAddDistributionGroup'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesAddDistributionGroup'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesAddStore
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body7 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2012
     */
    public function releasesAddStore($release_id, $body, $owner_name, $app_name)
    {
        list($response) = $this->releasesAddStoreWithHttpInfo($release_id, $body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesAddStoreWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body7 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2012, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesAddStoreWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2012';
        $request = $this->releasesAddStoreRequest($release_id, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesAddStoreAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body7 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAddStoreAsync($release_id, $body, $owner_name, $app_name)
    {
        return $this->releasesAddStoreAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesAddStoreAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body7 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAddStoreAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2012';
        $request = $this->releasesAddStoreRequest($release_id, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesAddStore'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body7 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesAddStoreRequest($release_id, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesAddStore'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesAddStore'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesAddStore'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesAddStore'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesAddTesters
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body6 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2011
     */
    public function releasesAddTesters($release_id, $body, $owner_name, $app_name)
    {
        list($response) = $this->releasesAddTestersWithHttpInfo($release_id, $body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesAddTestersWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body6 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2011, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesAddTestersWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2011';
        $request = $this->releasesAddTestersRequest($release_id, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2011',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesAddTestersAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body6 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAddTestersAsync($release_id, $body, $owner_name, $app_name)
    {
        return $this->releasesAddTestersAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesAddTestersAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body6 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAddTestersAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2011';
        $request = $this->releasesAddTestersRequest($release_id, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesAddTesters'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body6 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesAddTestersRequest($release_id, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesAddTesters'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesAddTesters'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesAddTesters'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesAddTesters'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesAvailableToTester
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20034[]
     */
    public function releasesAvailableToTester($owner_name, $app_name, $published_only = null)
    {
        list($response) = $this->releasesAvailableToTesterWithHttpInfo($owner_name, $app_name, $published_only);
        return $response;
    }

    /**
     * Operation releasesAvailableToTesterWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20034[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesAvailableToTesterWithHttpInfo($owner_name, $app_name, $published_only = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20034[]';
        $request = $this->releasesAvailableToTesterRequest($owner_name, $app_name, $published_only);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20034[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesAvailableToTesterAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAvailableToTesterAsync($owner_name, $app_name, $published_only = null)
    {
        return $this->releasesAvailableToTesterAsyncWithHttpInfo($owner_name, $app_name, $published_only)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesAvailableToTesterAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesAvailableToTesterAsyncWithHttpInfo($owner_name, $app_name, $published_only = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20034[]';
        $request = $this->releasesAvailableToTesterRequest($owner_name, $app_name, $published_only);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesAvailableToTester'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesAvailableToTesterRequest($owner_name, $app_name, $published_only = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesAvailableToTester'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesAvailableToTester'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/filter_by_tester';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($published_only !== null) {
            $queryParams['published_only'] = ObjectSerializer::toQueryValue($published_only);
        }

        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesCreateReleaseUpload
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Body3 $body Optional parameters to create releases with user defined metadata (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesCreateReleaseUpload($owner_name, $app_name, $body = null)
    {
        list($response) = $this->releasesCreateReleaseUploadWithHttpInfo($owner_name, $app_name, $body);
        return $response;
    }

    /**
     * Operation releasesCreateReleaseUploadWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Body3 $body Optional parameters to create releases with user defined metadata (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesCreateReleaseUploadWithHttpInfo($owner_name, $app_name, $body = null)
    {
        $returnType = 'object';
        $request = $this->releasesCreateReleaseUploadRequest($owner_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesCreateReleaseUploadAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Body3 $body Optional parameters to create releases with user defined metadata (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesCreateReleaseUploadAsync($owner_name, $app_name, $body = null)
    {
        return $this->releasesCreateReleaseUploadAsyncWithHttpInfo($owner_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesCreateReleaseUploadAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Body3 $body Optional parameters to create releases with user defined metadata (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesCreateReleaseUploadAsyncWithHttpInfo($owner_name, $app_name, $body = null)
    {
        $returnType = 'object';
        $request = $this->releasesCreateReleaseUploadRequest($owner_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesCreateReleaseUpload'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\Body3 $body Optional parameters to create releases with user defined metadata (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesCreateReleaseUploadRequest($owner_name, $app_name, $body = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesCreateReleaseUpload'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesCreateReleaseUpload'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/uploads/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesDelete
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesDelete($release_id, $owner_name, $app_name)
    {
        $this->releasesDeleteWithHttpInfo($release_id, $owner_name, $app_name);
    }

    /**
     * Operation releasesDeleteWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesDeleteWithHttpInfo($release_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteRequest($release_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesDeleteAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteAsync($release_id, $owner_name, $app_name)
    {
        return $this->releasesDeleteAsyncWithHttpInfo($release_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteAsyncWithHttpInfo($release_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteRequest($release_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesDelete'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesDeleteRequest($release_id, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesDeleteDistributionGroup
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the distribution group (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesDeleteDistributionGroup($release_id, $group_id, $owner_name, $app_name)
    {
        $this->releasesDeleteDistributionGroupWithHttpInfo($release_id, $group_id, $owner_name, $app_name);
    }

    /**
     * Operation releasesDeleteDistributionGroupWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the distribution group (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesDeleteDistributionGroupWithHttpInfo($release_id, $group_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteDistributionGroupRequest($release_id, $group_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesDeleteDistributionGroupAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the distribution group (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteDistributionGroupAsync($release_id, $group_id, $owner_name, $app_name)
    {
        return $this->releasesDeleteDistributionGroupAsyncWithHttpInfo($release_id, $group_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesDeleteDistributionGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the distribution group (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteDistributionGroupAsyncWithHttpInfo($release_id, $group_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteDistributionGroupRequest($release_id, $group_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesDeleteDistributionGroup'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the distribution group (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesDeleteDistributionGroupRequest($release_id, $group_id, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesDeleteDistributionGroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling releasesDeleteDistributionGroup'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesDeleteDistributionGroup'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesDeleteDistributionGroup'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group_id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesDeleteDistributionStore
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $store_id The id of the distribution store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesDeleteDistributionStore($release_id, $store_id, $owner_name, $app_name)
    {
        $this->releasesDeleteDistributionStoreWithHttpInfo($release_id, $store_id, $owner_name, $app_name);
    }

    /**
     * Operation releasesDeleteDistributionStoreWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $store_id The id of the distribution store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesDeleteDistributionStoreWithHttpInfo($release_id, $store_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteDistributionStoreRequest($release_id, $store_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesDeleteDistributionStoreAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $store_id The id of the distribution store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteDistributionStoreAsync($release_id, $store_id, $owner_name, $app_name)
    {
        return $this->releasesDeleteDistributionStoreAsyncWithHttpInfo($release_id, $store_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesDeleteDistributionStoreAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $store_id The id of the distribution store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteDistributionStoreAsyncWithHttpInfo($release_id, $store_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteDistributionStoreRequest($release_id, $store_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesDeleteDistributionStore'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $store_id The id of the distribution store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesDeleteDistributionStoreRequest($release_id, $store_id, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesDeleteDistributionStore'
            );
        }
        // verify the required parameter 'store_id' is set
        if ($store_id === null || (is_array($store_id) && count($store_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_id when calling releasesDeleteDistributionStore'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesDeleteDistributionStore'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesDeleteDistributionStore'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores/{store_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($store_id !== null) {
            $resourcePath = str_replace(
                '{' . 'store_id' . '}',
                ObjectSerializer::toPathValue($store_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesDeleteDistributionTester
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesDeleteDistributionTester($release_id, $tester_id, $owner_name, $app_name)
    {
        $this->releasesDeleteDistributionTesterWithHttpInfo($release_id, $tester_id, $owner_name, $app_name);
    }

    /**
     * Operation releasesDeleteDistributionTesterWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesDeleteDistributionTesterWithHttpInfo($release_id, $tester_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteDistributionTesterRequest($release_id, $tester_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesDeleteDistributionTesterAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteDistributionTesterAsync($release_id, $tester_id, $owner_name, $app_name)
    {
        return $this->releasesDeleteDistributionTesterAsyncWithHttpInfo($release_id, $tester_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesDeleteDistributionTesterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteDistributionTesterAsyncWithHttpInfo($release_id, $tester_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteDistributionTesterRequest($release_id, $tester_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesDeleteDistributionTester'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesDeleteDistributionTesterRequest($release_id, $tester_id, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesDeleteDistributionTester'
            );
        }
        // verify the required parameter 'tester_id' is set
        if ($tester_id === null || (is_array($tester_id) && count($tester_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tester_id when calling releasesDeleteDistributionTester'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesDeleteDistributionTester'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesDeleteDistributionTester'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($tester_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tester_id' . '}',
                ObjectSerializer::toPathValue($tester_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesDeleteTesterFromDestinations
     *
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesDeleteTesterFromDestinations($tester_id, $owner_name, $app_name)
    {
        $this->releasesDeleteTesterFromDestinationsWithHttpInfo($tester_id, $owner_name, $app_name);
    }

    /**
     * Operation releasesDeleteTesterFromDestinationsWithHttpInfo
     *
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesDeleteTesterFromDestinationsWithHttpInfo($tester_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteTesterFromDestinationsRequest($tester_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesDeleteTesterFromDestinationsAsync
     *
     * 
     *
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteTesterFromDestinationsAsync($tester_id, $owner_name, $app_name)
    {
        return $this->releasesDeleteTesterFromDestinationsAsyncWithHttpInfo($tester_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesDeleteTesterFromDestinationsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteTesterFromDestinationsAsyncWithHttpInfo($tester_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->releasesDeleteTesterFromDestinationsRequest($tester_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesDeleteTesterFromDestinations'
     *
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesDeleteTesterFromDestinationsRequest($tester_id, $owner_name, $app_name)
    {
        // verify the required parameter 'tester_id' is set
        if ($tester_id === null || (is_array($tester_id) && count($tester_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tester_id when calling releasesDeleteTesterFromDestinations'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesDeleteTesterFromDestinations'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesDeleteTesterFromDestinations'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/testers/{tester_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($tester_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tester_id' . '}',
                ObjectSerializer::toPathValue($tester_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesDeleteWithDistributionGroupId
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  int $release_id The ID identifying the unique release. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesDeleteWithDistributionGroupId($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        $this->releasesDeleteWithDistributionGroupIdWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id);
    }

    /**
     * Operation releasesDeleteWithDistributionGroupIdWithHttpInfo
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  int $release_id The ID identifying the unique release. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesDeleteWithDistributionGroupIdWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        $returnType = '';
        $request = $this->releasesDeleteWithDistributionGroupIdRequest($owner_name, $app_name, $distribution_group_name, $release_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation releasesDeleteWithDistributionGroupIdAsync
     *
     * 
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  int $release_id The ID identifying the unique release. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteWithDistributionGroupIdAsync($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        return $this->releasesDeleteWithDistributionGroupIdAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesDeleteWithDistributionGroupIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  int $release_id The ID identifying the unique release. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesDeleteWithDistributionGroupIdAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        $returnType = '';
        $request = $this->releasesDeleteWithDistributionGroupIdRequest($owner_name, $app_name, $distribution_group_name, $release_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesDeleteWithDistributionGroupId'
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  int $release_id The ID identifying the unique release. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesDeleteWithDistributionGroupIdRequest($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesDeleteWithDistributionGroupId'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesDeleteWithDistributionGroupId'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling releasesDeleteWithDistributionGroupId'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesDeleteWithDistributionGroupId'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetIosManifest
     *
     * @param  string $app_id The ID of the application (required)
     * @param  int $release_id The release_id (required)
     * @param  string $token A hash that authorizes the download if it matches the release info. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesGetIosManifest($app_id, $release_id, $token)
    {
        $this->releasesGetIosManifestWithHttpInfo($app_id, $release_id, $token);
    }

    /**
     * Operation releasesGetIosManifestWithHttpInfo
     *
     * @param  string $app_id The ID of the application (required)
     * @param  int $release_id The release_id (required)
     * @param  string $token A hash that authorizes the download if it matches the release info. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetIosManifestWithHttpInfo($app_id, $release_id, $token)
    {
        $returnType = '';
        $request = $this->releasesGetIosManifestRequest($app_id, $release_id, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetIosManifestAsync
     *
     * 
     *
     * @param  string $app_id The ID of the application (required)
     * @param  int $release_id The release_id (required)
     * @param  string $token A hash that authorizes the download if it matches the release info. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetIosManifestAsync($app_id, $release_id, $token)
    {
        return $this->releasesGetIosManifestAsyncWithHttpInfo($app_id, $release_id, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetIosManifestAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_id The ID of the application (required)
     * @param  int $release_id The release_id (required)
     * @param  string $token A hash that authorizes the download if it matches the release info. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetIosManifestAsyncWithHttpInfo($app_id, $release_id, $token)
    {
        $returnType = '';
        $request = $this->releasesGetIosManifestRequest($app_id, $release_id, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetIosManifest'
     *
     * @param  string $app_id The ID of the application (required)
     * @param  int $release_id The release_id (required)
     * @param  string $token A hash that authorizes the download if it matches the release info. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetIosManifestRequest($app_id, $release_id, $token)
    {
        // verify the required parameter 'app_id' is set
        if ($app_id === null || (is_array($app_id) && count($app_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_id when calling releasesGetIosManifest'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesGetIosManifest'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling releasesGetIosManifest'
            );
        }

        $resourcePath = '/v0.1/public/apps/{app_id}/releases/{release_id}/ios_manifest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            $queryParams['token'] = ObjectSerializer::toQueryValue($token);
        }

        // path params
        if ($app_id !== null) {
            $resourcePath = str_replace(
                '{' . 'app_id' . '}',
                ObjectSerializer::toPathValue($app_id),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLatestByDistributionGroup
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $release_id Also supports the constant &#x60;latest&#x60;, which will return the latest release in the distribution group. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetLatestByDistributionGroup($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        list($response) = $this->releasesGetLatestByDistributionGroupWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id);
        return $response;
    }

    /**
     * Operation releasesGetLatestByDistributionGroupWithHttpInfo
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $release_id Also supports the constant &#x60;latest&#x60;, which will return the latest release in the distribution group. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLatestByDistributionGroupWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByDistributionGroupRequest($owner_name, $app_name, $distribution_group_name, $release_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 501:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLatestByDistributionGroupAsync
     *
     * 
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $release_id Also supports the constant &#x60;latest&#x60;, which will return the latest release in the distribution group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByDistributionGroupAsync($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        return $this->releasesGetLatestByDistributionGroupAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLatestByDistributionGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $release_id Also supports the constant &#x60;latest&#x60;, which will return the latest release in the distribution group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByDistributionGroupAsyncWithHttpInfo($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByDistributionGroupRequest($owner_name, $app_name, $distribution_group_name, $release_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLatestByDistributionGroup'
     *
     * @param  string $owner_name The name of the app owner (required)
     * @param  string $app_name The name of the app (required)
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $release_id Also supports the constant &#x60;latest&#x60;, which will return the latest release in the distribution group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLatestByDistributionGroupRequest($owner_name, $app_name, $distribution_group_name, $release_id)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesGetLatestByDistributionGroup'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesGetLatestByDistributionGroup'
            );
        }
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling releasesGetLatestByDistributionGroup'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesGetLatestByDistributionGroup'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLatestByHash
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release or &#39;latest&#39; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetLatestByHash($app_secret, $release_hash, $udid = null)
    {
        list($response) = $this->releasesGetLatestByHashWithHttpInfo($app_secret, $release_hash, $udid);
        return $response;
    }

    /**
     * Operation releasesGetLatestByHashWithHttpInfo
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release or &#39;latest&#39; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLatestByHashWithHttpInfo($app_secret, $release_hash, $udid = null)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByHashRequest($app_secret, $release_hash, $udid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLatestByHashAsync
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release or &#39;latest&#39; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByHashAsync($app_secret, $release_hash, $udid = null)
    {
        return $this->releasesGetLatestByHashAsyncWithHttpInfo($app_secret, $release_hash, $udid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLatestByHashAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release or &#39;latest&#39; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByHashAsyncWithHttpInfo($app_secret, $release_hash, $udid = null)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByHashRequest($app_secret, $release_hash, $udid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLatestByHash'
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release or &#39;latest&#39; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLatestByHashRequest($app_secret, $release_hash, $udid = null)
    {
        // verify the required parameter 'app_secret' is set
        if ($app_secret === null || (is_array($app_secret) && count($app_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_secret when calling releasesGetLatestByHash'
            );
        }
        // verify the required parameter 'release_hash' is set
        if ($release_hash === null || (is_array($release_hash) && count($release_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_hash when calling releasesGetLatestByHash'
            );
        }

        $resourcePath = '/v0.1/sdk/apps/{app_secret}/releases/{release_hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($udid !== null) {
            $queryParams['udid'] = ObjectSerializer::toQueryValue($udid);
        }

        // path params
        if ($app_secret !== null) {
            $resourcePath = str_replace(
                '{' . 'app_secret' . '}',
                ObjectSerializer::toPathValue($app_secret),
                $resourcePath
            );
        }
        // path params
        if ($release_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'release_hash' . '}',
                ObjectSerializer::toPathValue($release_hash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLatestByPublicDistributionGroup
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $distribution_group_id the id for destination (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetLatestByPublicDistributionGroup($app_secret, $distribution_group_id)
    {
        list($response) = $this->releasesGetLatestByPublicDistributionGroupWithHttpInfo($app_secret, $distribution_group_id);
        return $response;
    }

    /**
     * Operation releasesGetLatestByPublicDistributionGroupWithHttpInfo
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $distribution_group_id the id for destination (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLatestByPublicDistributionGroupWithHttpInfo($app_secret, $distribution_group_id)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByPublicDistributionGroupRequest($app_secret, $distribution_group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLatestByPublicDistributionGroupAsync
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $distribution_group_id the id for destination (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByPublicDistributionGroupAsync($app_secret, $distribution_group_id)
    {
        return $this->releasesGetLatestByPublicDistributionGroupAsyncWithHttpInfo($app_secret, $distribution_group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLatestByPublicDistributionGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $distribution_group_id the id for destination (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByPublicDistributionGroupAsyncWithHttpInfo($app_secret, $distribution_group_id)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByPublicDistributionGroupRequest($app_secret, $distribution_group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLatestByPublicDistributionGroup'
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $distribution_group_id the id for destination (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLatestByPublicDistributionGroupRequest($app_secret, $distribution_group_id)
    {
        // verify the required parameter 'app_secret' is set
        if ($app_secret === null || (is_array($app_secret) && count($app_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_secret when calling releasesGetLatestByPublicDistributionGroup'
            );
        }
        // verify the required parameter 'distribution_group_id' is set
        if ($distribution_group_id === null || (is_array($distribution_group_id) && count($distribution_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_id when calling releasesGetLatestByPublicDistributionGroup'
            );
        }

        $resourcePath = '/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_secret !== null) {
            $resourcePath = str_replace(
                '{' . 'app_secret' . '}',
                ObjectSerializer::toPathValue($app_secret),
                $resourcePath
            );
        }
        // path params
        if ($distribution_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_id' . '}',
                ObjectSerializer::toPathValue($distribution_group_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLatestByUser
     *
     * @param  string $release_id The ID of the release, or &#x60;latest&#x60; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $udid when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetLatestByUser($release_id, $owner_name, $app_name, $udid = null)
    {
        list($response) = $this->releasesGetLatestByUserWithHttpInfo($release_id, $owner_name, $app_name, $udid);
        return $response;
    }

    /**
     * Operation releasesGetLatestByUserWithHttpInfo
     *
     * @param  string $release_id The ID of the release, or &#x60;latest&#x60; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $udid when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLatestByUserWithHttpInfo($release_id, $owner_name, $app_name, $udid = null)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByUserRequest($release_id, $owner_name, $app_name, $udid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLatestByUserAsync
     *
     * 
     *
     * @param  string $release_id The ID of the release, or &#x60;latest&#x60; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $udid when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByUserAsync($release_id, $owner_name, $app_name, $udid = null)
    {
        return $this->releasesGetLatestByUserAsyncWithHttpInfo($release_id, $owner_name, $app_name, $udid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLatestByUserAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $release_id The ID of the release, or &#x60;latest&#x60; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $udid when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestByUserAsyncWithHttpInfo($release_id, $owner_name, $app_name, $udid = null)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestByUserRequest($release_id, $owner_name, $app_name, $udid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLatestByUser'
     *
     * @param  string $release_id The ID of the release, or &#x60;latest&#x60; to get the latest release from all the distribution groups assigned to the current user. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $udid when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLatestByUserRequest($release_id, $owner_name, $app_name, $udid = null)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesGetLatestByUser'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesGetLatestByUser'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesGetLatestByUser'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($udid !== null) {
            $queryParams['udid'] = ObjectSerializer::toQueryValue($udid);
        }

        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLatestPrivateRelease
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetLatestPrivateRelease($app_secret, $udid = null)
    {
        list($response) = $this->releasesGetLatestPrivateReleaseWithHttpInfo($app_secret, $udid);
        return $response;
    }

    /**
     * Operation releasesGetLatestPrivateReleaseWithHttpInfo
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLatestPrivateReleaseWithHttpInfo($app_secret, $udid = null)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestPrivateReleaseRequest($app_secret, $udid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLatestPrivateReleaseAsync
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestPrivateReleaseAsync($app_secret, $udid = null)
    {
        return $this->releasesGetLatestPrivateReleaseAsyncWithHttpInfo($app_secret, $udid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLatestPrivateReleaseAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestPrivateReleaseAsyncWithHttpInfo($app_secret, $udid = null)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestPrivateReleaseRequest($app_secret, $udid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLatestPrivateRelease'
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $udid When passing &#x60;udid&#x60; in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLatestPrivateReleaseRequest($app_secret, $udid = null)
    {
        // verify the required parameter 'app_secret' is set
        if ($app_secret === null || (is_array($app_secret) && count($app_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_secret when calling releasesGetLatestPrivateRelease'
            );
        }

        $resourcePath = '/v0.1/sdk/apps/{app_secret}/releases/private/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($udid !== null) {
            $queryParams['udid'] = ObjectSerializer::toQueryValue($udid);
        }

        // path params
        if ($app_secret !== null) {
            $resourcePath = str_replace(
                '{' . 'app_secret' . '}',
                ObjectSerializer::toPathValue($app_secret),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetLatestPublicRelease
     *
     * @param  string $app_secret The secret of the target application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetLatestPublicRelease($app_secret)
    {
        list($response) = $this->releasesGetLatestPublicReleaseWithHttpInfo($app_secret);
        return $response;
    }

    /**
     * Operation releasesGetLatestPublicReleaseWithHttpInfo
     *
     * @param  string $app_secret The secret of the target application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetLatestPublicReleaseWithHttpInfo($app_secret)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestPublicReleaseRequest($app_secret);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetLatestPublicReleaseAsync
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestPublicReleaseAsync($app_secret)
    {
        return $this->releasesGetLatestPublicReleaseAsyncWithHttpInfo($app_secret)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetLatestPublicReleaseAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetLatestPublicReleaseAsyncWithHttpInfo($app_secret)
    {
        $returnType = 'object';
        $request = $this->releasesGetLatestPublicReleaseRequest($app_secret);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetLatestPublicRelease'
     *
     * @param  string $app_secret The secret of the target application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetLatestPublicReleaseRequest($app_secret)
    {
        // verify the required parameter 'app_secret' is set
        if ($app_secret === null || (is_array($app_secret) && count($app_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_secret when calling releasesGetLatestPublicRelease'
            );
        }

        $resourcePath = '/v0.1/public/sdk/apps/{app_secret}/releases/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_secret !== null) {
            $resourcePath = str_replace(
                '{' . 'app_secret' . '}',
                ObjectSerializer::toPathValue($app_secret),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetPublicGroupsForReleaseByHash
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2005[]
     */
    public function releasesGetPublicGroupsForReleaseByHash($app_secret, $release_hash)
    {
        list($response) = $this->releasesGetPublicGroupsForReleaseByHashWithHttpInfo($app_secret, $release_hash);
        return $response;
    }

    /**
     * Operation releasesGetPublicGroupsForReleaseByHashWithHttpInfo
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2005[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetPublicGroupsForReleaseByHashWithHttpInfo($app_secret, $release_hash)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2005[]';
        $request = $this->releasesGetPublicGroupsForReleaseByHashRequest($app_secret, $release_hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2005[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetPublicGroupsForReleaseByHashAsync
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetPublicGroupsForReleaseByHashAsync($app_secret, $release_hash)
    {
        return $this->releasesGetPublicGroupsForReleaseByHashAsyncWithHttpInfo($app_secret, $release_hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetPublicGroupsForReleaseByHashAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetPublicGroupsForReleaseByHashAsyncWithHttpInfo($app_secret, $release_hash)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2005[]';
        $request = $this->releasesGetPublicGroupsForReleaseByHashRequest($app_secret, $release_hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetPublicGroupsForReleaseByHash'
     *
     * @param  string $app_secret The secret of the target application (required)
     * @param  string $release_hash The hash of the release (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetPublicGroupsForReleaseByHashRequest($app_secret, $release_hash)
    {
        // verify the required parameter 'app_secret' is set
        if ($app_secret === null || (is_array($app_secret) && count($app_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_secret when calling releasesGetPublicGroupsForReleaseByHash'
            );
        }
        // verify the required parameter 'release_hash' is set
        if ($release_hash === null || (is_array($release_hash) && count($release_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_hash when calling releasesGetPublicGroupsForReleaseByHash'
            );
        }

        $resourcePath = '/v0.1/public/sdk/apps/{app_secret}/releases/{release_hash}/public_distribution_groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_secret !== null) {
            $resourcePath = str_replace(
                '{' . 'app_secret' . '}',
                ObjectSerializer::toPathValue($app_secret),
                $resourcePath
            );
        }
        // path params
        if ($release_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'release_hash' . '}',
                ObjectSerializer::toPathValue($release_hash),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetReleaseUploadStatus
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesGetReleaseUploadStatus($upload_id, $owner_name, $app_name)
    {
        list($response) = $this->releasesGetReleaseUploadStatusWithHttpInfo($upload_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesGetReleaseUploadStatusWithHttpInfo
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetReleaseUploadStatusWithHttpInfo($upload_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releasesGetReleaseUploadStatusRequest($upload_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetReleaseUploadStatusAsync
     *
     * 
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetReleaseUploadStatusAsync($upload_id, $owner_name, $app_name)
    {
        return $this->releasesGetReleaseUploadStatusAsyncWithHttpInfo($upload_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetReleaseUploadStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetReleaseUploadStatusAsyncWithHttpInfo($upload_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releasesGetReleaseUploadStatusRequest($upload_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetReleaseUploadStatus'
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetReleaseUploadStatusRequest($upload_id, $owner_name, $app_name)
    {
        // verify the required parameter 'upload_id' is set
        if ($upload_id === null || (is_array($upload_id) && count($upload_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload_id when calling releasesGetReleaseUploadStatus'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesGetReleaseUploadStatus'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesGetReleaseUploadStatus'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($upload_id !== null) {
            $resourcePath = str_replace(
                '{' . 'upload_id' . '}',
                ObjectSerializer::toPathValue($upload_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesGetSparkleFeed
     *
     * @param  string $app_secret The secret of the application. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesGetSparkleFeed($app_secret)
    {
        $this->releasesGetSparkleFeedWithHttpInfo($app_secret);
    }

    /**
     * Operation releasesGetSparkleFeedWithHttpInfo
     *
     * @param  string $app_secret The secret of the application. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesGetSparkleFeedWithHttpInfo($app_secret)
    {
        $returnType = '';
        $request = $this->releasesGetSparkleFeedRequest($app_secret);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesGetSparkleFeedAsync
     *
     * 
     *
     * @param  string $app_secret The secret of the application. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetSparkleFeedAsync($app_secret)
    {
        return $this->releasesGetSparkleFeedAsyncWithHttpInfo($app_secret)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesGetSparkleFeedAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $app_secret The secret of the application. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesGetSparkleFeedAsyncWithHttpInfo($app_secret)
    {
        $returnType = '';
        $request = $this->releasesGetSparkleFeedRequest($app_secret);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesGetSparkleFeed'
     *
     * @param  string $app_secret The secret of the application. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesGetSparkleFeedRequest($app_secret)
    {
        // verify the required parameter 'app_secret' is set
        if ($app_secret === null || (is_array($app_secret) && count($app_secret) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_secret when calling releasesGetSparkleFeed'
            );
        }

        $resourcePath = '/v0.1/public/sparkle/apps/{app_secret}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($app_secret !== null) {
            $resourcePath = str_replace(
                '{' . 'app_secret' . '}',
                ObjectSerializer::toPathValue($app_secret),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     * @param  string $scope When the scope is &#39;tester&#39;, only includes releases that have been distributed to groups that the user belongs to. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20034[]
     */
    public function releasesList($owner_name, $app_name, $published_only = null, $scope = null)
    {
        list($response) = $this->releasesListWithHttpInfo($owner_name, $app_name, $published_only, $scope);
        return $response;
    }

    /**
     * Operation releasesListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     * @param  string $scope When the scope is &#39;tester&#39;, only includes releases that have been distributed to groups that the user belongs to. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20034[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesListWithHttpInfo($owner_name, $app_name, $published_only = null, $scope = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20034[]';
        $request = $this->releasesListRequest($owner_name, $app_name, $published_only, $scope);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20034[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     * @param  string $scope When the scope is &#39;tester&#39;, only includes releases that have been distributed to groups that the user belongs to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListAsync($owner_name, $app_name, $published_only = null, $scope = null)
    {
        return $this->releasesListAsyncWithHttpInfo($owner_name, $app_name, $published_only, $scope)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     * @param  string $scope When the scope is &#39;tester&#39;, only includes releases that have been distributed to groups that the user belongs to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListAsyncWithHttpInfo($owner_name, $app_name, $published_only = null, $scope = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20034[]';
        $request = $this->releasesListRequest($owner_name, $app_name, $published_only, $scope);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $published_only When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out. (optional)
     * @param  string $scope When the scope is &#39;tester&#39;, only includes releases that have been distributed to groups that the user belongs to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesListRequest($owner_name, $app_name, $published_only = null, $scope = null)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($published_only !== null) {
            $queryParams['published_only'] = ObjectSerializer::toQueryValue($published_only);
        }
        // query params
        if ($scope !== null) {
            $queryParams['scope'] = ObjectSerializer::toQueryValue($scope);
        }

        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesListByDistributionGroup
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20062[]
     */
    public function releasesListByDistributionGroup($distribution_group_name, $owner_name, $app_name)
    {
        list($response) = $this->releasesListByDistributionGroupWithHttpInfo($distribution_group_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesListByDistributionGroupWithHttpInfo
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20062[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesListByDistributionGroupWithHttpInfo($distribution_group_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20062[]';
        $request = $this->releasesListByDistributionGroupRequest($distribution_group_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20062[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesListByDistributionGroupAsync
     *
     * 
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListByDistributionGroupAsync($distribution_group_name, $owner_name, $app_name)
    {
        return $this->releasesListByDistributionGroupAsyncWithHttpInfo($distribution_group_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesListByDistributionGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListByDistributionGroupAsyncWithHttpInfo($distribution_group_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20062[]';
        $request = $this->releasesListByDistributionGroupRequest($distribution_group_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesListByDistributionGroup'
     *
     * @param  string $distribution_group_name The name of the distribution group. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesListByDistributionGroupRequest($distribution_group_name, $owner_name, $app_name)
    {
        // verify the required parameter 'distribution_group_name' is set
        if ($distribution_group_name === null || (is_array($distribution_group_name) && count($distribution_group_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $distribution_group_name when calling releasesListByDistributionGroup'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesListByDistributionGroup'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesListByDistributionGroup'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($distribution_group_name !== null) {
            $resourcePath = str_replace(
                '{' . 'distribution_group_name' . '}',
                ObjectSerializer::toPathValue($distribution_group_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesListLatest
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20034[]
     */
    public function releasesListLatest($owner_name, $app_name)
    {
        list($response) = $this->releasesListLatestWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesListLatestWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20034[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesListLatestWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20034[]';
        $request = $this->releasesListLatestRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20034[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesListLatestAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListLatestAsync($owner_name, $app_name)
    {
        return $this->releasesListLatestAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesListLatestAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListLatestAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20034[]';
        $request = $this->releasesListLatestRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesListLatest'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesListLatestRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesListLatest'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesListLatest'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/recent_releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesListTesterApps
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2004[]
     */
    public function releasesListTesterApps()
    {
        list($response) = $this->releasesListTesterAppsWithHttpInfo();
        return $response;
    }

    /**
     * Operation releasesListTesterAppsWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2004[], HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesListTesterAppsWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2004[]';
        $request = $this->releasesListTesterAppsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2004[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesListTesterAppsAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListTesterAppsAsync()
    {
        return $this->releasesListTesterAppsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesListTesterAppsAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesListTesterAppsAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2004[]';
        $request = $this->releasesListTesterAppsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesListTesterApps'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesListTesterAppsRequest()
    {

        $resourcePath = '/v0.1/tester/apps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesPutDistributionGroup
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the releases destination (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationGroupUpdateDetails $destination_group_update_details destination_group_update_details (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesPutDistributionGroup($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details = null)
    {
        $this->releasesPutDistributionGroupWithHttpInfo($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details);
    }

    /**
     * Operation releasesPutDistributionGroupWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the releases destination (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationGroupUpdateDetails $destination_group_update_details (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesPutDistributionGroupWithHttpInfo($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details = null)
    {
        $returnType = '';
        $request = $this->releasesPutDistributionGroupRequest($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesPutDistributionGroupAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the releases destination (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationGroupUpdateDetails $destination_group_update_details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesPutDistributionGroupAsync($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details = null)
    {
        return $this->releasesPutDistributionGroupAsyncWithHttpInfo($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesPutDistributionGroupAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the releases destination (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationGroupUpdateDetails $destination_group_update_details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesPutDistributionGroupAsyncWithHttpInfo($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details = null)
    {
        $returnType = '';
        $request = $this->releasesPutDistributionGroupRequest($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesPutDistributionGroup'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $group_id The id of the releases destination (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationGroupUpdateDetails $destination_group_update_details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesPutDistributionGroupRequest($release_id, $group_id, $owner_name, $app_name, $destination_group_update_details = null)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesPutDistributionGroup'
            );
        }
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling releasesPutDistributionGroup'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesPutDistributionGroup'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesPutDistributionGroup'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'group_id' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($destination_group_update_details)) {
            $_tempBody = $destination_group_update_details;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesPutDistributionTester
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationTesterUpdateDetails $destination_tester_update_details destination_tester_update_details (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function releasesPutDistributionTester($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details = null)
    {
        $this->releasesPutDistributionTesterWithHttpInfo($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details);
    }

    /**
     * Operation releasesPutDistributionTesterWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationTesterUpdateDetails $destination_tester_update_details (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesPutDistributionTesterWithHttpInfo($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details = null)
    {
        $returnType = '';
        $request = $this->releasesPutDistributionTesterRequest($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesPutDistributionTesterAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationTesterUpdateDetails $destination_tester_update_details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesPutDistributionTesterAsync($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details = null)
    {
        return $this->releasesPutDistributionTesterAsyncWithHttpInfo($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesPutDistributionTesterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationTesterUpdateDetails $destination_tester_update_details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesPutDistributionTesterAsyncWithHttpInfo($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details = null)
    {
        $returnType = '';
        $request = $this->releasesPutDistributionTesterRequest($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesPutDistributionTester'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  string $tester_id The id of the tester (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\DestinationTesterUpdateDetails $destination_tester_update_details (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesPutDistributionTesterRequest($release_id, $tester_id, $owner_name, $app_name, $destination_tester_update_details = null)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesPutDistributionTester'
            );
        }
        // verify the required parameter 'tester_id' is set
        if ($tester_id === null || (is_array($tester_id) && count($tester_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tester_id when calling releasesPutDistributionTester'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesPutDistributionTester'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesPutDistributionTester'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($tester_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tester_id' . '}',
                ObjectSerializer::toPathValue($tester_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($destination_tester_update_details)) {
            $_tempBody = $destination_tester_update_details;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesUpdate
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body9 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesUpdate($release_id, $body, $owner_name, $app_name)
    {
        list($response) = $this->releasesUpdateWithHttpInfo($release_id, $body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesUpdateWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body9 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesUpdateWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releasesUpdateRequest($release_id, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesUpdateAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body9 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateAsync($release_id, $body, $owner_name, $app_name)
    {
        return $this->releasesUpdateAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body9 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releasesUpdateRequest($release_id, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesUpdate'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body9 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesUpdateRequest($release_id, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesUpdate'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesUpdateDetails
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body8 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesUpdateDetails($release_id, $body, $owner_name, $app_name)
    {
        list($response) = $this->releasesUpdateDetailsWithHttpInfo($release_id, $body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation releasesUpdateDetailsWithHttpInfo
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body8 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesUpdateDetailsWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releasesUpdateDetailsRequest($release_id, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse400',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesUpdateDetailsAsync
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body8 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateDetailsAsync($release_id, $body, $owner_name, $app_name)
    {
        return $this->releasesUpdateDetailsAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesUpdateDetailsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body8 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateDetailsAsyncWithHttpInfo($release_id, $body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->releasesUpdateDetailsRequest($release_id, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesUpdateDetails'
     *
     * @param  int $release_id The ID of the release (required)
     * @param  \Swagger\Client\Model\Body8 $body The release information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesUpdateDetailsRequest($release_id, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling releasesUpdateDetails'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesUpdateDetails'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesUpdateDetails'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesUpdateDetails'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation releasesUpdateReleaseUploadStatus
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  \Swagger\Client\Model\Body2 $body The release upload status information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $extract A flag that indicates to extract release or not, true by default (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function releasesUpdateReleaseUploadStatus($upload_id, $body, $owner_name, $app_name, $extract = null)
    {
        list($response) = $this->releasesUpdateReleaseUploadStatusWithHttpInfo($upload_id, $body, $owner_name, $app_name, $extract);
        return $response;
    }

    /**
     * Operation releasesUpdateReleaseUploadStatusWithHttpInfo
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  \Swagger\Client\Model\Body2 $body The release upload status information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $extract A flag that indicates to extract release or not, true by default (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function releasesUpdateReleaseUploadStatusWithHttpInfo($upload_id, $body, $owner_name, $app_name, $extract = null)
    {
        $returnType = 'object';
        $request = $this->releasesUpdateReleaseUploadStatusRequest($upload_id, $body, $owner_name, $app_name, $extract);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation releasesUpdateReleaseUploadStatusAsync
     *
     * 
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  \Swagger\Client\Model\Body2 $body The release upload status information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $extract A flag that indicates to extract release or not, true by default (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseUploadStatusAsync($upload_id, $body, $owner_name, $app_name, $extract = null)
    {
        return $this->releasesUpdateReleaseUploadStatusAsyncWithHttpInfo($upload_id, $body, $owner_name, $app_name, $extract)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation releasesUpdateReleaseUploadStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  \Swagger\Client\Model\Body2 $body The release upload status information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $extract A flag that indicates to extract release or not, true by default (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function releasesUpdateReleaseUploadStatusAsyncWithHttpInfo($upload_id, $body, $owner_name, $app_name, $extract = null)
    {
        $returnType = 'object';
        $request = $this->releasesUpdateReleaseUploadStatusRequest($upload_id, $body, $owner_name, $app_name, $extract);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'releasesUpdateReleaseUploadStatus'
     *
     * @param  string $upload_id The ID of the release upload (required)
     * @param  \Swagger\Client\Model\Body2 $body The release upload status information. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  bool $extract A flag that indicates to extract release or not, true by default (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function releasesUpdateReleaseUploadStatusRequest($upload_id, $body, $owner_name, $app_name, $extract = null)
    {
        // verify the required parameter 'upload_id' is set
        if ($upload_id === null || (is_array($upload_id) && count($upload_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload_id when calling releasesUpdateReleaseUploadStatus'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling releasesUpdateReleaseUploadStatus'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling releasesUpdateReleaseUploadStatus'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling releasesUpdateReleaseUploadStatus'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($extract !== null) {
            $queryParams['extract'] = ObjectSerializer::toQueryValue($extract);
        }

        // path params
        if ($upload_id !== null) {
            $resourcePath = str_replace(
                '{' . 'upload_id' . '}',
                ObjectSerializer::toPathValue($upload_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeNotificationsGetNotificationByAppId
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function storeNotificationsGetNotificationByAppId($owner_name, $app_name)
    {
        list($response) = $this->storeNotificationsGetNotificationByAppIdWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storeNotificationsGetNotificationByAppIdWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeNotificationsGetNotificationByAppIdWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storeNotificationsGetNotificationByAppIdRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeNotificationsGetNotificationByAppIdAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeNotificationsGetNotificationByAppIdAsync($owner_name, $app_name)
    {
        return $this->storeNotificationsGetNotificationByAppIdAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeNotificationsGetNotificationByAppIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeNotificationsGetNotificationByAppIdAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storeNotificationsGetNotificationByAppIdRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeNotificationsGetNotificationByAppId'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeNotificationsGetNotificationByAppIdRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeNotificationsGetNotificationByAppId'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeNotificationsGetNotificationByAppId'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/store_service_status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasePublishLogsGet
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The ID of the realease (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeReleasePublishLogsGet($store_name, $release_id, $owner_name, $app_name)
    {
        $this->storeReleasePublishLogsGetWithHttpInfo($store_name, $release_id, $owner_name, $app_name);
    }

    /**
     * Operation storeReleasePublishLogsGetWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The ID of the realease (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasePublishLogsGetWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->storeReleasePublishLogsGetRequest($store_name, $release_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasePublishLogsGetAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The ID of the realease (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasePublishLogsGetAsync($store_name, $release_id, $owner_name, $app_name)
    {
        return $this->storeReleasePublishLogsGetAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasePublishLogsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The ID of the realease (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasePublishLogsGetAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->storeReleasePublishLogsGetRequest($store_name, $release_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasePublishLogsGet'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The ID of the realease (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasePublishLogsGetRequest($store_name, $release_id, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasePublishLogsGet'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling storeReleasePublishLogsGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasePublishLogsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasePublishLogsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasesDelete
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storeReleasesDelete($store_name, $release_id, $owner_name, $app_name, $body = null)
    {
        $this->storeReleasesDeleteWithHttpInfo($store_name, $release_id, $owner_name, $app_name, $body);
    }

    /**
     * Operation storeReleasesDeleteWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasesDeleteWithHttpInfo($store_name, $release_id, $owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->storeReleasesDeleteRequest($store_name, $release_id, $owner_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasesDeleteAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesDeleteAsync($store_name, $release_id, $owner_name, $app_name, $body = null)
    {
        return $this->storeReleasesDeleteAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasesDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesDeleteAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->storeReleasesDeleteRequest($store_name, $release_id, $owner_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasesDelete'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasesDeleteRequest($store_name, $release_id, $owner_name, $app_name, $body = null)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasesDelete'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling storeReleasesDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasesDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasesDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasesGet
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20059[]
     */
    public function storeReleasesGet($store_name, $release_id, $owner_name, $app_name)
    {
        list($response) = $this->storeReleasesGetWithHttpInfo($store_name, $release_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storeReleasesGetWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20059[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasesGetWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20059[]';
        $request = $this->storeReleasesGetRequest($store_name, $release_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20059[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasesGetAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetAsync($store_name, $release_id, $owner_name, $app_name)
    {
        return $this->storeReleasesGetAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20059[]';
        $request = $this->storeReleasesGetRequest($store_name, $release_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasesGet'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $release_id The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasesGetRequest($store_name, $release_id, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasesGet'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling storeReleasesGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasesGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasesGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasesGetLatest
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20059[]
     */
    public function storeReleasesGetLatest($store_name, $owner_name, $app_name)
    {
        list($response) = $this->storeReleasesGetLatestWithHttpInfo($store_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storeReleasesGetLatestWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20059[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasesGetLatestWithHttpInfo($store_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20059[]';
        $request = $this->storeReleasesGetLatestRequest($store_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20059[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasesGetLatestAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetLatestAsync($store_name, $owner_name, $app_name)
    {
        return $this->storeReleasesGetLatestAsyncWithHttpInfo($store_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasesGetLatestAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetLatestAsyncWithHttpInfo($store_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20059[]';
        $request = $this->storeReleasesGetLatestRequest($store_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasesGetLatest'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasesGetLatestRequest($store_name, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasesGetLatest'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasesGetLatest'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasesGetLatest'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasesGetPublishError
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function storeReleasesGetPublishError($store_name, $release_id, $owner_name, $app_name)
    {
        list($response) = $this->storeReleasesGetPublishErrorWithHttpInfo($store_name, $release_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storeReleasesGetPublishErrorWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasesGetPublishErrorWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storeReleasesGetPublishErrorRequest($store_name, $release_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasesGetPublishErrorAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetPublishErrorAsync($store_name, $release_id, $owner_name, $app_name)
    {
        return $this->storeReleasesGetPublishErrorAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasesGetPublishErrorAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetPublishErrorAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storeReleasesGetPublishErrorRequest($store_name, $release_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasesGetPublishError'
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasesGetPublishErrorRequest($store_name, $release_id, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasesGetPublishError'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling storeReleasesGetPublishError'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasesGetPublishError'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasesGetPublishError'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_error_details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasesGetRealTimeStatusByReleaseId
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function storeReleasesGetRealTimeStatusByReleaseId($store_name, $release_id, $owner_name, $app_name)
    {
        list($response) = $this->storeReleasesGetRealTimeStatusByReleaseIdWithHttpInfo($store_name, $release_id, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storeReleasesGetRealTimeStatusByReleaseIdWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasesGetRealTimeStatusByReleaseIdWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storeReleasesGetRealTimeStatusByReleaseIdRequest($store_name, $release_id, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasesGetRealTimeStatusByReleaseIdAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetRealTimeStatusByReleaseIdAsync($store_name, $release_id, $owner_name, $app_name)
    {
        return $this->storeReleasesGetRealTimeStatusByReleaseIdAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasesGetRealTimeStatusByReleaseIdAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesGetRealTimeStatusByReleaseIdAsyncWithHttpInfo($store_name, $release_id, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storeReleasesGetRealTimeStatusByReleaseIdRequest($store_name, $release_id, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasesGetRealTimeStatusByReleaseId'
     *
     * @param  string $store_name The name of the store (required)
     * @param  float $release_id The id of the release (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasesGetRealTimeStatusByReleaseIdRequest($store_name, $release_id, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasesGetRealTimeStatusByReleaseId'
            );
        }
        // verify the required parameter 'release_id' is set
        if ($release_id === null || (is_array($release_id) && count($release_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_id when calling storeReleasesGetRealTimeStatusByReleaseId'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasesGetRealTimeStatusByReleaseId'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasesGetRealTimeStatusByReleaseId'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/realtimestatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($release_id !== null) {
            $resourcePath = str_replace(
                '{' . 'release_id' . '}',
                ObjectSerializer::toPathValue($release_id),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeReleasesList
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20060[]
     */
    public function storeReleasesList($store_name, $owner_name, $app_name)
    {
        list($response) = $this->storeReleasesListWithHttpInfo($store_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storeReleasesListWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20060[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storeReleasesListWithHttpInfo($store_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20060[]';
        $request = $this->storeReleasesListRequest($store_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20060[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storeReleasesListAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesListAsync($store_name, $owner_name, $app_name)
    {
        return $this->storeReleasesListAsyncWithHttpInfo($store_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeReleasesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeReleasesListAsyncWithHttpInfo($store_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20060[]';
        $request = $this->storeReleasesListRequest($store_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeReleasesList'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storeReleasesListRequest($store_name, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storeReleasesList'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storeReleasesList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storeReleasesList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storesCreate
     *
     * @param  \Swagger\Client\Model\Body13 $body The store request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function storesCreate($body, $owner_name, $app_name)
    {
        list($response) = $this->storesCreateWithHttpInfo($body, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storesCreateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\Body13 $body The store request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function storesCreateWithHttpInfo($body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storesCreateRequest($body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storesCreateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\Body13 $body The store request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesCreateAsync($body, $owner_name, $app_name)
    {
        return $this->storesCreateAsyncWithHttpInfo($body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storesCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\Body13 $body The store request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesCreateAsyncWithHttpInfo($body, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storesCreateRequest($body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storesCreate'
     *
     * @param  \Swagger\Client\Model\Body13 $body The store request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storesCreateRequest($body, $owner_name, $app_name)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling storesCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storesCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storesCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storesDelete
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storesDelete($store_name, $owner_name, $app_name, $body = null)
    {
        $this->storesDeleteWithHttpInfo($store_name, $owner_name, $app_name, $body);
    }

    /**
     * Operation storesDeleteWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storesDeleteWithHttpInfo($store_name, $owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->storesDeleteRequest($store_name, $owner_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storesDeleteAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesDeleteAsync($store_name, $owner_name, $app_name, $body = null)
    {
        return $this->storesDeleteAsyncWithHttpInfo($store_name, $owner_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storesDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesDeleteAsyncWithHttpInfo($store_name, $owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->storesDeleteRequest($store_name, $owner_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storesDelete'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storesDeleteRequest($store_name, $owner_name, $app_name, $body = null)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storesDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storesDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storesDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storesGet
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function storesGet($store_name, $owner_name, $app_name)
    {
        list($response) = $this->storesGetWithHttpInfo($store_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storesGetWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function storesGetWithHttpInfo($store_name, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storesGetRequest($store_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storesGetAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesGetAsync($store_name, $owner_name, $app_name)
    {
        return $this->storesGetAsyncWithHttpInfo($store_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesGetAsyncWithHttpInfo($store_name, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->storesGetRequest($store_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storesGet'
     *
     * @param  string $store_name The name of the store (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storesGetRequest($store_name, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storesGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storesGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storesGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storesList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20061[]
     */
    public function storesList($owner_name, $app_name)
    {
        list($response) = $this->storesListWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation storesListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20061[], HTTP status code, HTTP response headers (array of strings)
     */
    public function storesListWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20061[]';
        $request = $this->storesListRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20061[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storesListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesListAsync($owner_name, $app_name)
    {
        return $this->storesListAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storesListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesListAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20061[]';
        $request = $this->storesListRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storesList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storesListRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storesList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storesList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storesPatch
     *
     * @param  string $store_name The name of the store (required)
     * @param  \Swagger\Client\Model\Body12 $body Store update request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function storesPatch($store_name, $body, $owner_name, $app_name)
    {
        $this->storesPatchWithHttpInfo($store_name, $body, $owner_name, $app_name);
    }

    /**
     * Operation storesPatchWithHttpInfo
     *
     * @param  string $store_name The name of the store (required)
     * @param  \Swagger\Client\Model\Body12 $body Store update request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function storesPatchWithHttpInfo($store_name, $body, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->storesPatchRequest($store_name, $body, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storesPatchAsync
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  \Swagger\Client\Model\Body12 $body Store update request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesPatchAsync($store_name, $body, $owner_name, $app_name)
    {
        return $this->storesPatchAsyncWithHttpInfo($store_name, $body, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storesPatchAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $store_name The name of the store (required)
     * @param  \Swagger\Client\Model\Body12 $body Store update request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesPatchAsyncWithHttpInfo($store_name, $body, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->storesPatchRequest($store_name, $body, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storesPatch'
     *
     * @param  string $store_name The name of the store (required)
     * @param  \Swagger\Client\Model\Body12 $body Store update request (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function storesPatchRequest($store_name, $body, $owner_name, $app_name)
    {
        // verify the required parameter 'store_name' is set
        if ($store_name === null || (is_array($store_name) && count($store_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $store_name when calling storesPatch'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling storesPatch'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling storesPatch'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling storesPatch'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($store_name !== null) {
            $resourcePath = str_replace(
                '{' . 'store_name' . '}',
                ObjectSerializer::toPathValue($store_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
