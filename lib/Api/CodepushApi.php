<?php
/**
 * CodepushApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * App Center Client
 *
 * Microsoft Visual Studio App Center API
 *
 * OpenAPI spec version: v0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * CodepushApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CodepushApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation codePushAcquisitionGetAcquisitionStatus
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function codePushAcquisitionGetAcquisitionStatus()
    {
        list($response) = $this->codePushAcquisitionGetAcquisitionStatusWithHttpInfo();
        return $response;
    }

    /**
     * Operation codePushAcquisitionGetAcquisitionStatusWithHttpInfo
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushAcquisitionGetAcquisitionStatusWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->codePushAcquisitionGetAcquisitionStatusRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushAcquisitionGetAcquisitionStatusAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionGetAcquisitionStatusAsync()
    {
        return $this->codePushAcquisitionGetAcquisitionStatusAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushAcquisitionGetAcquisitionStatusAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionGetAcquisitionStatusAsyncWithHttpInfo()
    {
        $returnType = 'object';
        $request = $this->codePushAcquisitionGetAcquisitionStatusRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushAcquisitionGetAcquisitionStatus'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushAcquisitionGetAcquisitionStatusRequest()
    {

        $resourcePath = '/v0.1/public/codepush/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushAcquisitionUpdateCheck
     *
     * @param  string $deployment_key deployment_key (required)
     * @param  string $app_version app_version (required)
     * @param  string $package_hash package_hash (optional)
     * @param  string $label label (optional)
     * @param  string $client_unique_id client_unique_id (optional)
     * @param  bool $is_companion is_companion (optional)
     * @param  string $previous_label_or_app_version previous_label_or_app_version (optional)
     * @param  string $previous_deployment_key previous_deployment_key (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function codePushAcquisitionUpdateCheck($deployment_key, $app_version, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null, $previous_label_or_app_version = null, $previous_deployment_key = null)
    {
        list($response) = $this->codePushAcquisitionUpdateCheckWithHttpInfo($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion, $previous_label_or_app_version, $previous_deployment_key);
        return $response;
    }

    /**
     * Operation codePushAcquisitionUpdateCheckWithHttpInfo
     *
     * @param  string $deployment_key (required)
     * @param  string $app_version (required)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  bool $is_companion (optional)
     * @param  string $previous_label_or_app_version (optional)
     * @param  string $previous_deployment_key (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushAcquisitionUpdateCheckWithHttpInfo($deployment_key, $app_version, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null, $previous_label_or_app_version = null, $previous_deployment_key = null)
    {
        $returnType = 'object';
        $request = $this->codePushAcquisitionUpdateCheckRequest($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion, $previous_label_or_app_version, $previous_deployment_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushAcquisitionUpdateCheckAsync
     *
     * 
     *
     * @param  string $deployment_key (required)
     * @param  string $app_version (required)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  bool $is_companion (optional)
     * @param  string $previous_label_or_app_version (optional)
     * @param  string $previous_deployment_key (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionUpdateCheckAsync($deployment_key, $app_version, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null, $previous_label_or_app_version = null, $previous_deployment_key = null)
    {
        return $this->codePushAcquisitionUpdateCheckAsyncWithHttpInfo($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion, $previous_label_or_app_version, $previous_deployment_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushAcquisitionUpdateCheckAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_key (required)
     * @param  string $app_version (required)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  bool $is_companion (optional)
     * @param  string $previous_label_or_app_version (optional)
     * @param  string $previous_deployment_key (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionUpdateCheckAsyncWithHttpInfo($deployment_key, $app_version, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null, $previous_label_or_app_version = null, $previous_deployment_key = null)
    {
        $returnType = 'object';
        $request = $this->codePushAcquisitionUpdateCheckRequest($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion, $previous_label_or_app_version, $previous_deployment_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushAcquisitionUpdateCheck'
     *
     * @param  string $deployment_key (required)
     * @param  string $app_version (required)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  bool $is_companion (optional)
     * @param  string $previous_label_or_app_version (optional)
     * @param  string $previous_deployment_key (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushAcquisitionUpdateCheckRequest($deployment_key, $app_version, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null, $previous_label_or_app_version = null, $previous_deployment_key = null)
    {
        // verify the required parameter 'deployment_key' is set
        if ($deployment_key === null || (is_array($deployment_key) && count($deployment_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_key when calling codePushAcquisitionUpdateCheck'
            );
        }
        // verify the required parameter 'app_version' is set
        if ($app_version === null || (is_array($app_version) && count($app_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_version when calling codePushAcquisitionUpdateCheck'
            );
        }

        $resourcePath = '/v0.1/public/codepush/update_check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deployment_key !== null) {
            $queryParams['deployment_key'] = ObjectSerializer::toQueryValue($deployment_key);
        }
        // query params
        if ($app_version !== null) {
            $queryParams['app_version'] = ObjectSerializer::toQueryValue($app_version);
        }
        // query params
        if ($package_hash !== null) {
            $queryParams['package_hash'] = ObjectSerializer::toQueryValue($package_hash);
        }
        // query params
        if ($label !== null) {
            $queryParams['label'] = ObjectSerializer::toQueryValue($label);
        }
        // query params
        if ($client_unique_id !== null) {
            $queryParams['client_unique_id'] = ObjectSerializer::toQueryValue($client_unique_id);
        }
        // query params
        if ($is_companion !== null) {
            $queryParams['is_companion'] = ObjectSerializer::toQueryValue($is_companion);
        }
        // query params
        if ($previous_label_or_app_version !== null) {
            $queryParams['previous_label_or_app_version'] = ObjectSerializer::toQueryValue($previous_label_or_app_version);
        }
        // query params
        if ($previous_deployment_key !== null) {
            $queryParams['previous_deployment_key'] = ObjectSerializer::toQueryValue($previous_deployment_key);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushAcquisitionUpdateDeployStatus
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function codePushAcquisitionUpdateDeployStatus($release_metadata)
    {
        $this->codePushAcquisitionUpdateDeployStatusWithHttpInfo($release_metadata);
    }

    /**
     * Operation codePushAcquisitionUpdateDeployStatusWithHttpInfo
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushAcquisitionUpdateDeployStatusWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->codePushAcquisitionUpdateDeployStatusRequest($release_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushAcquisitionUpdateDeployStatusAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionUpdateDeployStatusAsync($release_metadata)
    {
        return $this->codePushAcquisitionUpdateDeployStatusAsyncWithHttpInfo($release_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushAcquisitionUpdateDeployStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionUpdateDeployStatusAsyncWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->codePushAcquisitionUpdateDeployStatusRequest($release_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushAcquisitionUpdateDeployStatus'
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushAcquisitionUpdateDeployStatusRequest($release_metadata)
    {
        // verify the required parameter 'release_metadata' is set
        if ($release_metadata === null || (is_array($release_metadata) && count($release_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_metadata when calling codePushAcquisitionUpdateDeployStatus'
            );
        }

        $resourcePath = '/v0.1/public/codepush/report_status/deploy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($release_metadata)) {
            $_tempBody = $release_metadata;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushAcquisitionUpdateDownloadStatus
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function codePushAcquisitionUpdateDownloadStatus($release_metadata)
    {
        $this->codePushAcquisitionUpdateDownloadStatusWithHttpInfo($release_metadata);
    }

    /**
     * Operation codePushAcquisitionUpdateDownloadStatusWithHttpInfo
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushAcquisitionUpdateDownloadStatusWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->codePushAcquisitionUpdateDownloadStatusRequest($release_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushAcquisitionUpdateDownloadStatusAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionUpdateDownloadStatusAsync($release_metadata)
    {
        return $this->codePushAcquisitionUpdateDownloadStatusAsyncWithHttpInfo($release_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushAcquisitionUpdateDownloadStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushAcquisitionUpdateDownloadStatusAsyncWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->codePushAcquisitionUpdateDownloadStatusRequest($release_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushAcquisitionUpdateDownloadStatus'
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushAcquisitionUpdateDownloadStatusRequest($release_metadata)
    {
        // verify the required parameter 'release_metadata' is set
        if ($release_metadata === null || (is_array($release_metadata) && count($release_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_metadata when calling codePushAcquisitionUpdateDownloadStatus'
            );
        }

        $resourcePath = '/v0.1/public/codepush/report_status/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($release_metadata)) {
            $_tempBody = $release_metadata;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentMetricsGet
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20065[]
     */
    public function codePushDeploymentMetricsGet($deployment_name, $owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentMetricsGetWithHttpInfo($deployment_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentMetricsGetWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20065[], HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentMetricsGetWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20065[]';
        $request = $this->codePushDeploymentMetricsGetRequest($deployment_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20065[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentMetricsGetAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentMetricsGetAsync($deployment_name, $owner_name, $app_name)
    {
        return $this->codePushDeploymentMetricsGetAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentMetricsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentMetricsGetAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20065[]';
        $request = $this->codePushDeploymentMetricsGetRequest($deployment_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentMetricsGet'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentMetricsGetRequest($deployment_name, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentMetricsGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentMetricsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentMetricsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/metrics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentReleaseRollback
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\ReleaseLabel $release_label The specific release label that you want to rollback to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function codePushDeploymentReleaseRollback($deployment_name, $owner_name, $app_name, $release_label = null)
    {
        list($response) = $this->codePushDeploymentReleaseRollbackWithHttpInfo($deployment_name, $owner_name, $app_name, $release_label);
        return $response;
    }

    /**
     * Operation codePushDeploymentReleaseRollbackWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\ReleaseLabel $release_label The specific release label that you want to rollback to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentReleaseRollbackWithHttpInfo($deployment_name, $owner_name, $app_name, $release_label = null)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentReleaseRollbackRequest($deployment_name, $owner_name, $app_name, $release_label);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentReleaseRollbackAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\ReleaseLabel $release_label The specific release label that you want to rollback to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleaseRollbackAsync($deployment_name, $owner_name, $app_name, $release_label = null)
    {
        return $this->codePushDeploymentReleaseRollbackAsyncWithHttpInfo($deployment_name, $owner_name, $app_name, $release_label)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentReleaseRollbackAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\ReleaseLabel $release_label The specific release label that you want to rollback to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleaseRollbackAsyncWithHttpInfo($deployment_name, $owner_name, $app_name, $release_label = null)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentReleaseRollbackRequest($deployment_name, $owner_name, $app_name, $release_label);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentReleaseRollback'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  \Swagger\Client\Model\ReleaseLabel $release_label The specific release label that you want to rollback to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentReleaseRollbackRequest($deployment_name, $owner_name, $app_name, $release_label = null)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentReleaseRollback'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentReleaseRollback'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentReleaseRollback'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/rollback_release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($release_label)) {
            $_tempBody = $release_label;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentReleasesCreate
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\UploadedRelease $uploaded_release The necessary information required to download the bundle and being the release process. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function codePushDeploymentReleasesCreate($deployment_name, $uploaded_release, $owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentReleasesCreateWithHttpInfo($deployment_name, $uploaded_release, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentReleasesCreateWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\UploadedRelease $uploaded_release The necessary information required to download the bundle and being the release process. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentReleasesCreateWithHttpInfo($deployment_name, $uploaded_release, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentReleasesCreateRequest($deployment_name, $uploaded_release, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentReleasesCreateAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\UploadedRelease $uploaded_release The necessary information required to download the bundle and being the release process. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleasesCreateAsync($deployment_name, $uploaded_release, $owner_name, $app_name)
    {
        return $this->codePushDeploymentReleasesCreateAsyncWithHttpInfo($deployment_name, $uploaded_release, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentReleasesCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\UploadedRelease $uploaded_release The necessary information required to download the bundle and being the release process. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleasesCreateAsyncWithHttpInfo($deployment_name, $uploaded_release, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentReleasesCreateRequest($deployment_name, $uploaded_release, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentReleasesCreate'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\UploadedRelease $uploaded_release The necessary information required to download the bundle and being the release process. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentReleasesCreateRequest($deployment_name, $uploaded_release, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentReleasesCreate'
            );
        }
        // verify the required parameter 'uploaded_release' is set
        if ($uploaded_release === null || (is_array($uploaded_release) && count($uploaded_release) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uploaded_release when calling codePushDeploymentReleasesCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentReleasesCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentReleasesCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($uploaded_release)) {
            $_tempBody = $uploaded_release;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentReleasesDelete
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function codePushDeploymentReleasesDelete($deployment_name, $owner_name, $app_name)
    {
        $this->codePushDeploymentReleasesDeleteWithHttpInfo($deployment_name, $owner_name, $app_name);
    }

    /**
     * Operation codePushDeploymentReleasesDeleteWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentReleasesDeleteWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->codePushDeploymentReleasesDeleteRequest($deployment_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentReleasesDeleteAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleasesDeleteAsync($deployment_name, $owner_name, $app_name)
    {
        return $this->codePushDeploymentReleasesDeleteAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentReleasesDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleasesDeleteAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->codePushDeploymentReleasesDeleteRequest($deployment_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentReleasesDelete'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentReleasesDeleteRequest($deployment_name, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentReleasesDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentReleasesDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentReleasesDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentReleasesGet
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object[]
     */
    public function codePushDeploymentReleasesGet($deployment_name, $owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentReleasesGetWithHttpInfo($deployment_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentReleasesGetWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object[], HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentReleasesGetWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = 'object[]';
        $request = $this->codePushDeploymentReleasesGetRequest($deployment_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentReleasesGetAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleasesGetAsync($deployment_name, $owner_name, $app_name)
    {
        return $this->codePushDeploymentReleasesGetAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentReleasesGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentReleasesGetAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = 'object[]';
        $request = $this->codePushDeploymentReleasesGetRequest($deployment_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentReleasesGet'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentReleasesGetRequest($deployment_name, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentReleasesGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentReleasesGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentReleasesGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentUploadCreate
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function codePushDeploymentUploadCreate($deployment_name, $owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentUploadCreateWithHttpInfo($deployment_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentUploadCreateWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentUploadCreateWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentUploadCreateRequest($deployment_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentUploadCreateAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentUploadCreateAsync($deployment_name, $owner_name, $app_name)
    {
        return $this->codePushDeploymentUploadCreateAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentUploadCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentUploadCreateAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentUploadCreateRequest($deployment_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentUploadCreate'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentUploadCreateRequest($deployment_name, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentUploadCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentUploadCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentUploadCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/uploads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentsCreate
     *
     * @param  \Swagger\Client\Model\Deployment1 $deployment Deployment to be created (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Deployment1
     */
    public function codePushDeploymentsCreate($deployment, $owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentsCreateWithHttpInfo($deployment, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentsCreateWithHttpInfo
     *
     * @param  \Swagger\Client\Model\Deployment1 $deployment Deployment to be created (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Deployment1, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentsCreateWithHttpInfo($deployment, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\Deployment1';
        $request = $this->codePushDeploymentsCreateRequest($deployment, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Deployment1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentsCreateAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\Deployment1 $deployment Deployment to be created (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsCreateAsync($deployment, $owner_name, $app_name)
    {
        return $this->codePushDeploymentsCreateAsyncWithHttpInfo($deployment, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentsCreateAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\Deployment1 $deployment Deployment to be created (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsCreateAsyncWithHttpInfo($deployment, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\Deployment1';
        $request = $this->codePushDeploymentsCreateRequest($deployment, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentsCreate'
     *
     * @param  \Swagger\Client\Model\Deployment1 $deployment Deployment to be created (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentsCreateRequest($deployment, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment' is set
        if ($deployment === null || (is_array($deployment) && count($deployment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment when calling codePushDeploymentsCreate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentsCreate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentsCreate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($deployment)) {
            $_tempBody = $deployment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentsDelete
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function codePushDeploymentsDelete($deployment_name, $owner_name, $app_name, $body = null)
    {
        $this->codePushDeploymentsDeleteWithHttpInfo($deployment_name, $owner_name, $app_name, $body);
    }

    /**
     * Operation codePushDeploymentsDeleteWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentsDeleteWithHttpInfo($deployment_name, $owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->codePushDeploymentsDeleteRequest($deployment_name, $owner_name, $app_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentsDeleteAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsDeleteAsync($deployment_name, $owner_name, $app_name, $body = null)
    {
        return $this->codePushDeploymentsDeleteAsyncWithHttpInfo($deployment_name, $owner_name, $app_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentsDeleteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsDeleteAsyncWithHttpInfo($deployment_name, $owner_name, $app_name, $body = null)
    {
        $returnType = '';
        $request = $this->codePushDeploymentsDeleteRequest($deployment_name, $owner_name, $app_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentsDelete'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentsDeleteRequest($deployment_name, $owner_name, $app_name, $body = null)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentsDelete'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentsDelete'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentsDelete'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentsGet
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20066
     */
    public function codePushDeploymentsGet($deployment_name, $owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentsGetWithHttpInfo($deployment_name, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentsGetWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20066, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentsGetWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20066';
        $request = $this->codePushDeploymentsGetRequest($deployment_name, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20066',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentsGetAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsGetAsync($deployment_name, $owner_name, $app_name)
    {
        return $this->codePushDeploymentsGetAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentsGetAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsGetAsyncWithHttpInfo($deployment_name, $owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20066';
        $request = $this->codePushDeploymentsGetRequest($deployment_name, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentsGet'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentsGetRequest($deployment_name, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentsGet'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentsGet'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentsGet'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentsList
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse20066[]
     */
    public function codePushDeploymentsList($owner_name, $app_name)
    {
        list($response) = $this->codePushDeploymentsListWithHttpInfo($owner_name, $app_name);
        return $response;
    }

    /**
     * Operation codePushDeploymentsListWithHttpInfo
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse20066[], HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentsListWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20066[]';
        $request = $this->codePushDeploymentsListRequest($owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse20066[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentsListAsync
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsListAsync($owner_name, $app_name)
    {
        return $this->codePushDeploymentsListAsyncWithHttpInfo($owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentsListAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsListAsyncWithHttpInfo($owner_name, $app_name)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse20066[]';
        $request = $this->codePushDeploymentsListRequest($owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentsList'
     *
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentsListRequest($owner_name, $app_name)
    {
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentsList'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentsList'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentsPromote
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $promote_deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $release Release to be promoted, only needs to provide optional fields, description, label, disabled, mandatory, rollout, targetBinaryVersion (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function codePushDeploymentsPromote($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release = null)
    {
        list($response) = $this->codePushDeploymentsPromoteWithHttpInfo($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release);
        return $response;
    }

    /**
     * Operation codePushDeploymentsPromoteWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $promote_deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $release Release to be promoted, only needs to provide optional fields, description, label, disabled, mandatory, rollout, targetBinaryVersion (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentsPromoteWithHttpInfo($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release = null)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentsPromoteRequest($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentsPromoteAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $promote_deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $release Release to be promoted, only needs to provide optional fields, description, label, disabled, mandatory, rollout, targetBinaryVersion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsPromoteAsync($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release = null)
    {
        return $this->codePushDeploymentsPromoteAsyncWithHttpInfo($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentsPromoteAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $promote_deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $release Release to be promoted, only needs to provide optional fields, description, label, disabled, mandatory, rollout, targetBinaryVersion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsPromoteAsyncWithHttpInfo($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release = null)
    {
        $returnType = 'object';
        $request = $this->codePushDeploymentsPromoteRequest($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentsPromote'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $promote_deployment_name deployment name (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     * @param  object $release Release to be promoted, only needs to provide optional fields, description, label, disabled, mandatory, rollout, targetBinaryVersion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentsPromoteRequest($deployment_name, $promote_deployment_name, $owner_name, $app_name, $release = null)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentsPromote'
            );
        }
        // verify the required parameter 'promote_deployment_name' is set
        if ($promote_deployment_name === null || (is_array($promote_deployment_name) && count($promote_deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $promote_deployment_name when calling codePushDeploymentsPromote'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentsPromote'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentsPromote'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/promote_release/{promote_deployment_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($promote_deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'promote_deployment_name' . '}',
                ObjectSerializer::toPathValue($promote_deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($release)) {
            $_tempBody = $release;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation codePushDeploymentsUpdate
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\Deployment $deployment Deployment modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function codePushDeploymentsUpdate($deployment_name, $deployment, $owner_name, $app_name)
    {
        $this->codePushDeploymentsUpdateWithHttpInfo($deployment_name, $deployment, $owner_name, $app_name);
    }

    /**
     * Operation codePushDeploymentsUpdateWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\Deployment $deployment Deployment modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function codePushDeploymentsUpdateWithHttpInfo($deployment_name, $deployment, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->codePushDeploymentsUpdateRequest($deployment_name, $deployment, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation codePushDeploymentsUpdateAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\Deployment $deployment Deployment modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsUpdateAsync($deployment_name, $deployment, $owner_name, $app_name)
    {
        return $this->codePushDeploymentsUpdateAsyncWithHttpInfo($deployment_name, $deployment, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation codePushDeploymentsUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\Deployment $deployment Deployment modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function codePushDeploymentsUpdateAsyncWithHttpInfo($deployment_name, $deployment, $owner_name, $app_name)
    {
        $returnType = '';
        $request = $this->codePushDeploymentsUpdateRequest($deployment_name, $deployment, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'codePushDeploymentsUpdate'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  \Swagger\Client\Model\Deployment $deployment Deployment modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function codePushDeploymentsUpdateRequest($deployment_name, $deployment, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling codePushDeploymentsUpdate'
            );
        }
        // verify the required parameter 'deployment' is set
        if ($deployment === null || (is_array($deployment) && count($deployment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment when calling codePushDeploymentsUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling codePushDeploymentsUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling codePushDeploymentsUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($deployment)) {
            $_tempBody = $deployment;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deploymentReleasesUpdate
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $release_label release label (required)
     * @param  object $release Release modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deploymentReleasesUpdate($deployment_name, $release_label, $release, $owner_name, $app_name)
    {
        list($response) = $this->deploymentReleasesUpdateWithHttpInfo($deployment_name, $release_label, $release, $owner_name, $app_name);
        return $response;
    }

    /**
     * Operation deploymentReleasesUpdateWithHttpInfo
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $release_label release label (required)
     * @param  object $release Release modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deploymentReleasesUpdateWithHttpInfo($deployment_name, $release_label, $release, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->deploymentReleasesUpdateRequest($deployment_name, $release_label, $release, $owner_name, $app_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deploymentReleasesUpdateAsync
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $release_label release label (required)
     * @param  object $release Release modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deploymentReleasesUpdateAsync($deployment_name, $release_label, $release, $owner_name, $app_name)
    {
        return $this->deploymentReleasesUpdateAsyncWithHttpInfo($deployment_name, $release_label, $release, $owner_name, $app_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deploymentReleasesUpdateAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $release_label release label (required)
     * @param  object $release Release modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deploymentReleasesUpdateAsyncWithHttpInfo($deployment_name, $release_label, $release, $owner_name, $app_name)
    {
        $returnType = 'object';
        $request = $this->deploymentReleasesUpdateRequest($deployment_name, $release_label, $release, $owner_name, $app_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deploymentReleasesUpdate'
     *
     * @param  string $deployment_name deployment name (required)
     * @param  string $release_label release label (required)
     * @param  object $release Release modification. All fields are optional and only provided fields will get updated. (required)
     * @param  string $owner_name The name of the owner (required)
     * @param  string $app_name The name of the application (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deploymentReleasesUpdateRequest($deployment_name, $release_label, $release, $owner_name, $app_name)
    {
        // verify the required parameter 'deployment_name' is set
        if ($deployment_name === null || (is_array($deployment_name) && count($deployment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deployment_name when calling deploymentReleasesUpdate'
            );
        }
        // verify the required parameter 'release_label' is set
        if ($release_label === null || (is_array($release_label) && count($release_label) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_label when calling deploymentReleasesUpdate'
            );
        }
        // verify the required parameter 'release' is set
        if ($release === null || (is_array($release) && count($release) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release when calling deploymentReleasesUpdate'
            );
        }
        // verify the required parameter 'owner_name' is set
        if ($owner_name === null || (is_array($owner_name) && count($owner_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner_name when calling deploymentReleasesUpdate'
            );
        }
        // verify the required parameter 'app_name' is set
        if ($app_name === null || (is_array($app_name) && count($app_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app_name when calling deploymentReleasesUpdate'
            );
        }

        $resourcePath = '/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases/{release_label}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($deployment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'deployment_name' . '}',
                ObjectSerializer::toPathValue($deployment_name),
                $resourcePath
            );
        }
        // path params
        if ($release_label !== null) {
            $resourcePath = str_replace(
                '{' . 'release_label' . '}',
                ObjectSerializer::toPathValue($release_label),
                $resourcePath
            );
        }
        // path params
        if ($owner_name !== null) {
            $resourcePath = str_replace(
                '{' . 'owner_name' . '}',
                ObjectSerializer::toPathValue($owner_name),
                $resourcePath
            );
        }
        // path params
        if ($app_name !== null) {
            $resourcePath = str_replace(
                '{' . 'app_name' . '}',
                ObjectSerializer::toPathValue($app_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($release)) {
            $_tempBody = $release;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateCheck
     *
     * @param  string $deployment_key deployment_key (optional)
     * @param  string $app_version app_version (optional)
     * @param  string $package_hash package_hash (optional)
     * @param  string $label label (optional)
     * @param  string $client_unique_id client_unique_id (optional)
     * @param  string $is_companion is_companion (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function legacyCodePushAcquisitionUpdateCheck($deployment_key = null, $app_version = null, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null)
    {
        list($response) = $this->legacyCodePushAcquisitionUpdateCheckWithHttpInfo($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion);
        return $response;
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateCheckWithHttpInfo
     *
     * @param  string $deployment_key (optional)
     * @param  string $app_version (optional)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  string $is_companion (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function legacyCodePushAcquisitionUpdateCheckWithHttpInfo($deployment_key = null, $app_version = null, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null)
    {
        $returnType = 'object';
        $request = $this->legacyCodePushAcquisitionUpdateCheckRequest($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateCheckAsync
     *
     * 
     *
     * @param  string $deployment_key (optional)
     * @param  string $app_version (optional)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  string $is_companion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function legacyCodePushAcquisitionUpdateCheckAsync($deployment_key = null, $app_version = null, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null)
    {
        return $this->legacyCodePushAcquisitionUpdateCheckAsyncWithHttpInfo($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateCheckAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $deployment_key (optional)
     * @param  string $app_version (optional)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  string $is_companion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function legacyCodePushAcquisitionUpdateCheckAsyncWithHttpInfo($deployment_key = null, $app_version = null, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null)
    {
        $returnType = 'object';
        $request = $this->legacyCodePushAcquisitionUpdateCheckRequest($deployment_key, $app_version, $package_hash, $label, $client_unique_id, $is_companion);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'legacyCodePushAcquisitionUpdateCheck'
     *
     * @param  string $deployment_key (optional)
     * @param  string $app_version (optional)
     * @param  string $package_hash (optional)
     * @param  string $label (optional)
     * @param  string $client_unique_id (optional)
     * @param  string $is_companion (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function legacyCodePushAcquisitionUpdateCheckRequest($deployment_key = null, $app_version = null, $package_hash = null, $label = null, $client_unique_id = null, $is_companion = null)
    {

        $resourcePath = '/v0.1/legacy/updateCheck';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deployment_key !== null) {
            $queryParams['deploymentKey'] = ObjectSerializer::toQueryValue($deployment_key);
        }
        // query params
        if ($app_version !== null) {
            $queryParams['appVersion'] = ObjectSerializer::toQueryValue($app_version);
        }
        // query params
        if ($package_hash !== null) {
            $queryParams['packageHash'] = ObjectSerializer::toQueryValue($package_hash);
        }
        // query params
        if ($label !== null) {
            $queryParams['label'] = ObjectSerializer::toQueryValue($label);
        }
        // query params
        if ($client_unique_id !== null) {
            $queryParams['clientUniqueId'] = ObjectSerializer::toQueryValue($client_unique_id);
        }
        // query params
        if ($is_companion !== null) {
            $queryParams['isCompanion'] = ObjectSerializer::toQueryValue($is_companion);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateDownloadStatus
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function legacyCodePushAcquisitionUpdateDownloadStatus($release_metadata)
    {
        $this->legacyCodePushAcquisitionUpdateDownloadStatusWithHttpInfo($release_metadata);
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateDownloadStatusWithHttpInfo
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function legacyCodePushAcquisitionUpdateDownloadStatusWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->legacyCodePushAcquisitionUpdateDownloadStatusRequest($release_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateDownloadStatusAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function legacyCodePushAcquisitionUpdateDownloadStatusAsync($release_metadata)
    {
        return $this->legacyCodePushAcquisitionUpdateDownloadStatusAsyncWithHttpInfo($release_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateDownloadStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function legacyCodePushAcquisitionUpdateDownloadStatusAsyncWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->legacyCodePushAcquisitionUpdateDownloadStatusRequest($release_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'legacyCodePushAcquisitionUpdateDownloadStatus'
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function legacyCodePushAcquisitionUpdateDownloadStatusRequest($release_metadata)
    {
        // verify the required parameter 'release_metadata' is set
        if ($release_metadata === null || (is_array($release_metadata) && count($release_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_metadata when calling legacyCodePushAcquisitionUpdateDownloadStatus'
            );
        }

        $resourcePath = '/v0.1/legacy/reportStatus/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($release_metadata)) {
            $_tempBody = $release_metadata;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateInstallsStatus
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function legacyCodePushAcquisitionUpdateInstallsStatus($release_metadata)
    {
        $this->legacyCodePushAcquisitionUpdateInstallsStatusWithHttpInfo($release_metadata);
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateInstallsStatusWithHttpInfo
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function legacyCodePushAcquisitionUpdateInstallsStatusWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->legacyCodePushAcquisitionUpdateInstallsStatusRequest($release_metadata);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateInstallsStatusAsync
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function legacyCodePushAcquisitionUpdateInstallsStatusAsync($release_metadata)
    {
        return $this->legacyCodePushAcquisitionUpdateInstallsStatusAsyncWithHttpInfo($release_metadata)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation legacyCodePushAcquisitionUpdateInstallsStatusAsyncWithHttpInfo
     *
     * 
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function legacyCodePushAcquisitionUpdateInstallsStatusAsyncWithHttpInfo($release_metadata)
    {
        $returnType = '';
        $request = $this->legacyCodePushAcquisitionUpdateInstallsStatusRequest($release_metadata);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'legacyCodePushAcquisitionUpdateInstallsStatus'
     *
     * @param  \Swagger\Client\Model\ReleaseMetadata1 $release_metadata Deployment status metric properties (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function legacyCodePushAcquisitionUpdateInstallsStatusRequest($release_metadata)
    {
        // verify the required parameter 'release_metadata' is set
        if ($release_metadata === null || (is_array($release_metadata) && count($release_metadata) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $release_metadata when calling legacyCodePushAcquisitionUpdateInstallsStatus'
            );
        }

        $resourcePath = '/v0.1/legacy/reportStatus/deploy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($release_metadata)) {
            $_tempBody = $release_metadata;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Token');
        if ($apiKey !== null) {
            $headers['X-API-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
